

[toc]

# 十八. 声明

> 

## 18.1 声明的语法

`声明说明符 声明符`

**声明说明符**（declaration specifier）

+ **存储类型**：最多出现一种，必须在最前；一共有4种：`auto、static、extern、register`
+ **类型限定符**：可以包含零个或者多个；C88两种：`const、volatile`。C99还有一种：`restrict`。
+ **类型说明符**：包括结构、联合、枚举的说明，用 `typedef` 创建的类型名也是，关键字 `void、char、short、int、long、float、double、signed、unsigned`
+ **函数说明符**：C99，`inline`

> 类型限定符 和 类型说明符的相互顺序没有要求

**声明符**（declarator）：包括标识符（简单变量的名字）、后面跟随的 `[]` 标识符（数组名）、前放置 `*` 的标识符（指针名）、后边跟随 `()` 的标识符（函数名）。

## 18.2 存储类型

### 18.2.1 变量的性质

+ **存储期限**：决定为变量预留和内存被释放的时间
  + *自动存储期限*：块终止释放
  + *静态存储期限*：无限期保留
+ **作用域**：可以引用变量的那部分程序文本
  + *块作用域*
  + *文件作用域*
+ **链接**：确定了程序不同部分可以共享此变量的范围
  + *外部链接*：被程序中的几个（或者全部）文件共享
  + *内部链接*：属于单独一个文件，文件中的函数可以共享
  + *无链接*：属于单独一个函数，不能被共享

> 变量的默认存储期限、作用域和链接都依赖于**变量声明的位置**

+ 块：自动存储期限、块作用域、无链接
+ 程序最外层：静态存储期限、文件作用域、外部链接

### 18.2.2 auto 存储类型

只对块内变量有效。自动存储期限、块作用域、无链接

### 18.2.3 static 存储类型

可以用于全部变量

+ 块外部：静态存储期限、文件作用域、**内部链接**
+ 块内部：**静态存储期限**、块作用域、无链接

> 用于块外部，使得变量只在声明它的文件内可见

### 18.2.4 extern 存储类型

让几个源文件可以共享同一个变量

始终有静态存储期限，作用域依赖于声明的位置

+ 块外部：静态存储期限、文件作用域、**什么链接？**
+ 块内部：静态存储期限、块作用域、**什么链接？**

> 如果变量在文件中较早的位置（任何函数定义外部），那么具有内部链接；否则（通常情况下），具有外部链接

### 18.2.5 register 存储类型

要求编译器把变量存储在寄存器中，而不是保存在内存中；是一种请求；

只对块内变量有效。*自动存储期限、块作用域、无链接*。

不可以对 register 变量使用取地址运算符 `&`

最好用于需要频繁访问或者更新的变量，比如 for 循环中的控制变量

### 18.2.6 函数的存储类型

选项只有 `extern` 和 `static`

+ extern：外部链接
+ static：内部链接
+ 不指明：外部链接

> 声明函数是 `extern` 如同声明变量是 `auto` 的一样，两者都没有作用

声明函数是 `static` 是十分有用的。声明不打算被其他文件调用的任意函数，建议使用 `static` 存储类型

+ **更容易维护**
+ **减少了 “名字空间污染”**

> 函数的形式参数具有和 `auto` 变量相同的性质；唯一能作用域形式参数的存储类型是 `register`

```c
int a;
extern int b;
static int c;

void f(int d, register int e) {
	auto int g;
	int h;
	static int i;
	extern int j;
	register int k;
}
```

| 名字 | 存储期限 | 作用域 | 链接 |
| ---- | -------- | ------ | ---- |
| a    | 静态     | 文件   | 外部 |
| b    | 静态     | 文件   | ①    |
| c    | 静态     | 文件   | 内部 |
| d    | 自动     | 块     | 无   |
| e    | 自动     | 块     | 无   |
| g    | 自动     | 块     | 无   |
| h    | 自动     | 块     | 无   |
| i    | 静态     | 块     | 无   |
| j    | 静态     | 块     | ①    |
| k    | 自动     | 块     | 无   |

> ① 由于这里没有显示出变量 b 和 j 的定义，所以不可能确定它们的链接。在大多数情况下，变量会定义在另一个文件中，并具有外部链接

> 在这4种存储类型之中，最重要的是 `extern` 和 `static`。`auto` 没有任何效果，而现代编译器己经使 `register` 变得不如以前重要了

## 18.3 类型限定符

> 两种类型限定符：`const` 和  `volatile`

> C99：`restrict`

**const**

## 18.4 声明符

> 声明符包含标识符（声明的变量或函数的名字），标识符前面可能有符号 `*`，后面可能有 `[]` 或 `()`

### 18.4.1 解释复杂声明

+ 始终从内往外读声明符
+ 在做选择时，始终让 `[]` 和 `()` 优先于 `*`

```c
int *(*x[10])(void)
```

> 首先，定位声明的标识符 `x`。在 `x` 前有 `*` ，而后边又跟着 `[]`。因为 `[]` 优先级高于`*`，所以取右侧（`x` 是数组）。接下来，从左侧找到数组中元素的类型（指针）。再接下来，到右侧找到指针所指向的数据类型（不带实际参数的函数）。最后，回到左侧看每个函数返回的内容（指向 int型的指针）。

+ 函数不能返回数组
+ 函数不能返回函数
+ 函数型的数组也不行
+ 只能用指针来获取所需的效果

### 18.4.2 使用类型定义来简化声明

```c
int *(*x[10])(void)
```

为了让 `x` 的类型更容易理解，使用下面一系列的类型定义：

```c
typedef int *Fcn(void);
typedef Fcn *Fcn_ptr;
typedef Fcn_ptr Fcn_ptr_array[10];
Fcn_ptr_array x;
```

## 18.5 初始化式

> 声明变量时为他们指定初始值
>
> 声明符后面书写符号=，然后跟上初始化式
>
> 声明中的符号=和赋值运算符不一样

额外规则

+ 具有**静态存储期限**的变量初始化式必须是常量
+ 变量具有**自动存储期限**，初始化式不需要是常量
+ 包含在花括号中的数组、结构或者联合的初始化式必须只包含常量表达式，不允许有变量或函数调用
  + C99 中，仅当变量具有静态存储期限才有此限制
+ 自动类型的结构或者联合的初始化式可以是另一个结构或联合

**未初始化的变量**

+ 自动存储期限的变量没有默认的初始值
+ 静态存储期限的变量默认情况下的值为零，基于类型的正确初始化

## 18.6 内联函数

函数额外开销：调用函数和从函数返回所需的工作量

避免函数额外开销

+ 带参数的宏（14.3 节）
+ 创建**内联函数**（inline function）

>  并不是强制，只是建议

### 18.6.1 内联定义

```c
inline double average(double a, double b) {
  return (a + b) / 2;
}
```

**问题**：试图在别的文件中调用 `average` 是错误的，因为他的定义是内联定义，但是他又有外部链接

**解决方法**

1. 在函数定义中增加 `static` 

```c
static inline double average(double a, double b) {
  return (a + b) / 2;
}
```

2. 为 `average` 提供外部定义
   1. 将该函数重写一遍（不使用 `inline`）
   2. 将 `average` 的内联定义放入头文件，再创建与之匹配的源文件，任何一个需要调用 `average` 函数的文件只需要简单包含头文件即可。

average.h

```c
#ifndef AVERAGE_H
#define AVERAGE_H

inline double average(double a, double b) {
  return (a + b) / 2;
}

#endif
```

average.c

```c
#include "average.h"

extern double average(double a, double b);
```

> average.h 包含了 `average` 的内联定义；
>
> average.c 包含了 `average` 的原型；
>
> 由于使用了 `extern` 关键字，因此 average.h 中的 `average` 的定义在 average.c 中被认为是外部定义

### 18.6.2 对内联函数的限制

C99 对具有外部链接的内联函数做了限制

+ 函数中不能定义可改变的 static 变量
+ 函数中不能引用具有内部链接的变量

### 18.6.3 在 GCC 中使用内联函数

> 仅当通过 `-O` 命令行选项请求进行优化时，才会对函数进行“内联”

## 问与答

**问：在 C99 中，为什么把选择语句和重复语句（以及他们的“内部”语句）视为块？**

答：这条奇怪的规则来源于把复合字面量 （➡️9.3节、➡️16.2节）用于选择语句和重复语句时出现的一个问题。该问题与复合字面量的存储期限有关，所以我们先花点时间讨论一下这个问题。

C99 标准指出，如果复合字面量出现在函数体之外，那么复合字面量所表示的对象具有静态存储期限。否则，它具有自动存储期限，因而对象所占有的内存会在复合字面量所在块的末尾释放。考虑下面的函数，该函数返回使用复合字面量创建的 `point` 结构：

```c
struct point create_point(int x, int y) {
  return (struct point) {x, y};
}
```

这个函数可以正确工作，因为复合字面量创建的对象会在函数返回时被复制。原始的对象将不复存在，但副本会保留。现在假设我们对函数进行微小的改动：

```c
struct point *create_point(int x, int y) {
  return &(struct point) {x, y};
}
```

这一版本的 `create_point` 函数会导致未定义的行为，因为它返回的指针所指向的对象具有自动存储期限，函数返回后该对象不复存在。

现在回到开始提到的问题：为什么把选择语句和重复语句视为块？考虑下面的例子：

```c
/* Example 1 - if statement without braces */

double *coefficients, values;

if (polynomial_selected == 1)
  coefficients = (double[3]) {1.5, -3.0, 6.0};
else
  coefficients = (double[3]) {4.5, 1.0, -3.5};
value = evaluate_polynomial(coefficients);
```

这个程序片段显然能按需要的方式工作（但是请继续阅读)。`coefficients` 将指向由复合字面量创建的两个对象之一，并且该对象在调用 `evaluate_polynomial `时仍然存在。现在考虑一下，如果在内部语句（if 语句控制的语句）两边加上花括号，会有什么不同：

```c
/* Example 2 - if statement with braces */

double *coefficients, values;

if (polynomial_selected == 1) {
  coefficients = (double[3]) {1.5, -3.0, 6.0};
} else {
  coefficients = (double[3]) {4.5, 1.0, -3.5};
}
value = evaluate_polynomial(coefficients);
```

现在我们遇到问题了。每个复合字面量会创建一个对象，但是该对象只存在于包含相应语句的花括号所形成的块内。调用 `evaluate_polynomial` 时，`coefficients` 指向一个不存在的对象，从而导致未定义的行为。

C99 的创立者对这种现象很不满意，因为程序员不可能期望在 `if `语句中简单地增加花括号就会导致未定义的行为。为了避免这一问题，他们决定始终把内部语句视为块。这样一来，示例 1 和示例 2 就等价了，都会导致未定义的行为。

当复合字面量是选择语句或重复语句的控制表达式的一部分时，类似的问题也会发生。因此，我们把整个选择语句和重复语向也都看作块（就好像有一对不可见的花括号括在整个语句外面一样）。因此，带有 `else `子句的 `if` 语句包含三个块：两个内部语句分别是一个块，整个 `if` 语句又是一个块。

**问：你曾说过，具有自动存储期限的变量在所在块开始执行时分配内存空间。这对于 C99 的变长数组是否也成立？ （p.328）**

答：不成立。变长数组的空间不会在所在块开始执行时就分配，因为那时候还不知道数组的长度。事实上，在块的执行到达变长数组声明时才会为其分配空间。从这一方面说，变长数组不同于其他所有的自动变量。

**问：“作用域”和“链接”之间的区别到底是什么？（p.329）**

作用域是为编译器服务的，而链接则是为链接器服务的。编译器用标识符的作用域来确定在文件的给定位置访问标识符是否合法。当编译器把源文件翻译成目标代码时，它会注意到有外部链接的名字，并最终把这些名字存储到目标文件内的一个表中。因此，链接器可以访问到具有外部链接的名字，而内部链接的名字或无链接的名字对链接器而言是不可见的。

**问：我无法理解一个名字具有块作用域但是却有着外部链接。可否详细解释一下？（p.331）**

答：当然可以。假设某个源文件定义了变量 `i`

```c
int i;
```

假设变量 `i` 的定义放在了任意函数之外，所以默认情况下他具有外部链接。在另一个文件中，有一个函数 `f` 需要访问变量 `i`，所以`f` 的函数体把 `i` 声明为 `extern`：

```c
void f(void) {
	extern int i;
	...
}
```

在第一个文件中，变量 `i`具有文件作用域。但是，在函数 `f` 内， `i` 具有块作用域。如果除函数 `f` 以外的其他函数需要访问变量 `i`，那么它们将需单独声明 `i`（或者简单地把变量 `i` 的声明移到函数 `f` 外，从而使其具有文件作用域）。在整个过程中会混淆的就是：每次声明或定义 `i` 都会建立不同的作用域，有时是文件作用域，有时是块作用域。

**问：为什么不能把 `const` 对象用在常量表达式中呢？“constant” 不就是常量吗？（p.333）**

答：在C语言中，`const` 表示“只读” 而不是“常量”。下面用几个例子说明为什么 `const` 对象不能用于常量表达式。

首先，`const` 对象只在它的**生命期**内为常量，而不是在程序的整个执行期内。假设在函数体内声明了一个 `const` 对象：

```c
void f(int n) {
  const int m = n / 2;
  ...
}
```

当调用函数 `f` 时，`m` 将会被初始化为 `n/2`，`m` 的值在函数 `f` 返回之前都保持不变。当再次调用函数 `f` 时，`m` 可能会得到不同的值。这就是出现问题的地方。假设 `m `出现在 `switch` 语句中：

```c
void f(int n) {
  const int m = n / 2;
  ...
  switch (...) {
      ...
      case m: ...   /*** WRONG ***/
      ...
  }
  ...
}
```

那么直到函数 `f` 调用之前 `m` 的值都是未知的，这违反了C语言的规则——分支标号的值必须是常量表达式。

接下来看看声明在块外部的 `const` 对象。这些对象具有外部链接，并且可以在文件之间进行共享。如果C语言允许在常量表达式中使用 `const` 对象，我们很容易遇到下列情况：

```c
extern const int n;
int a[n];           /*** WRONG ***/
```

`n` 可能在其他文件中定义，这使编译器无法确定数组 `a` 的长度（假设 `a` 是外部变量，所以它不可能是变长数组）。

如果这样还不能让你信服，考虑下面的情况：如果一个`const`对象也用`volatile`类型限定符（➡️20.3节）声明，它的值可能在程序执行过程中的任何时间发生改变。下面是C标准中的一个例子：

```c
extern const volatile int real_time_clock;
```

程序可能不会改变变量`real_time_clock`的值（因为它被声明为const），但是可以通过其他某种机制修改它的值 （因为它被声明为volatile）。

**问：为什么声明符的语法如此古怪？**

答：声明试图进行模拟使用。指针声明符的格式为 `*p`，这种格式和稍后将用于 `p` 的间接寻址运算符方式相匹配。数组声明符的格式为 `a[…]`，这种格式和数组稍后的取下标方式相匹配。函数声明符的格式为 `f(…)`，这种格式和函数调用的语法相匹配。这种推理甚至可以扩展到最复杂的声明符上。请思考一下17.7节中的数组 `file_cmd`，此数组的元素都是指向函数的指针。数组`file_cmd` 的声明符格式为

```c
(*file_cmd[])(void)
```

而这些函数的调用格式为

```c
(*file_cmd[n])();
```

其中圆括号、方括号和 `*` 的位置都一样。