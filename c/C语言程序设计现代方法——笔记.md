

[toc]

# 十八. 声明

> 

## 18.1 声明的语法

`声明说明符 声明符`

**声明说明符**（declaration specifier）

+ **存储类型**：最多出现一种，必须在最前；一共有4种：`auto、static、extern、register`
+ **类型限定符**：可以包含零个或者多个；C88两种：`const、volatile`。C99还有一种：`restrict`。
+ **类型说明符**：包括结构、联合、枚举的说明，用 `typedef` 创建的类型名也是，关键字 `void、char、short、int、long、float、double、signed、unsigned`
+ **函数说明符**：C99，`inline`

> 类型限定符 和 类型说明符的相互顺序没有要求

**声明符**（declarator）：包括标识符（简单变量的名字）、后面跟随的 `[]` 标识符（数组名）、前放置 `*` 的标识符（指针名）、后边跟随 `()` 的标识符（函数名）。

## 18.2 存储类型

### 18.2.1 变量的性质

+ **存储期限**：决定为变量预留和内存被释放的时间
  + *自动存储期限*：块终止释放
  + *静态存储期限*：无限期保留
+ **作用域**：可以引用变量的那部分程序文本
  + *块作用域*
  + *文件作用域*
+ **链接**：确定了程序不同部分可以共享此变量的范围
  + *外部链接*：被程序中的几个（或者全部）文件共享
  + *内部链接*：属于单独一个文件，文件中的函数可以共享
  + *无链接*：属于单独一个函数，不能被共享

> 变量的默认存储期限、作用域和链接都依赖于**变量声明的位置**

+ 块：自动存储期限、块作用域、无链接
+ 程序最外层：静态存储期限、文件作用域、外部链接

### 18.2.2 auto 存储类型

只对块内变量有效。自动存储期限、块作用域、无链接

### 18.2.3 static 存储类型

可以用于全部变量

+ 块外部：静态存储期限、文件作用域、**内部链接**
+ 块内部：**静态存储期限**、块作用域、无链接

> 用于块外部，使得变量只在声明它的文件内可见

### 18.2.4 extern 存储类型

让几个源文件可以共享同一个变量

始终有静态存储期限，作用域依赖于声明的位置

+ 块外部：静态存储期限、文件作用域、**什么链接？**
+ 块内部：静态存储期限、块作用域、**什么链接？**

> 如果变量在文件中较早的位置（任何函数定义外部），那么具有内部链接；否则（通常情况下），具有外部链接

### 18.2.5 register 存储类型

要求编译器把变量存储在寄存器中，而不是保存在内存中；是一种请求；

只对块内变量有效。自动存储期限、块作用域、无链接。

不可以对 register 变量使用取地址运算符 &

最好用于需要频繁访问或者更新的变量，比如 for 循环中的控制变量

### 18.2.6 函数的存储类型

选项只有 `extern` 和 `static`

+ extern：外部链接
+ static：内部链接
+ 不指明：外部链接

> 声明函数是 `extern` 如同声明变量是 `auto` 的一样，两者都没有作用

声明函数是 `static` 是十分有用的。声明不打算被其他文件调用的任意函数，建议使用 `static` 存储类型

+ **更容易维护**
+ **减少了 “名字空间污染”**

> 函数的形式参数具有和 `auto` 变量相同的性质；唯一能作用域形式参数的存储类型是 `register`

```c
int a;
extern int b;
static int c;

void f(int d, register int e) {
	auto int g;
	int h;
	static int i;
	extern int j;
	register int k;
}
```

| 名字 | 存储期限 | 作用域 | 链接 |
| ---- | -------- | ------ | ---- |
| a    | 静态     | 文件   | 外部 |
| b    | 静态     | 文件   | ①    |
| c    | 静态     | 文件   | 内部 |
| d    | 自动     | 块     | 无   |
| e    | 自动     | 块     | 无   |
| g    | 自动     | 块     | 无   |
| h    | 自动     | 块     | 无   |
| i    | 静态     | 块     | 无   |
| j    | 静态     | 块     | ①    |
| k    | 自动     | 块     | 无   |

> ① 由于这里没有显示出变量 b 和 j 的定义，所以不可能确定它们的链接。在大多数情况下，变量会定义在另一个文件中，并具有外部链接

> 在这4种存储类型之中，最重要的是 `extern` 和 `static`。`auto` 没有任何效果，而现代编译器己经使 `register` 变得不如以前重要了

## 18.3 类型限定符

> 两种类型限定符：`const` 和  `volatile`

> C99：`restrict`

**const**

## 18.4 声明符

> 声明符包含标识符（声明的变量或函数的名字），标识符前面可能有符号 `*`，后面可能有 `[]` 或 `()`

### 18.4.1 解释复杂声明

+ 始终从内往外读声明符
+ 在做选择时，始终让 `[]` 和 `()` 优先于 `*`

```c
int *(*x[10])(void)
```

> 首先，定位声明的标识符 `x`。在 `x` 前有 `*` ，而后边又跟着 `[]`。因为 `[]` 优先级高于`*`，所以取右侧（`x` 是数组）。接下来，从左侧找到数组中元素的类型（指针）。再接下来，到右侧找到指针所指向的数据类型（不带实际参数的函数）。最后，回到左侧看每个函数返回的内容（指向 int型的指针）。

+ 函数不能返回数组
+ 函数不能返回函数
+ 函数型的数组也不行
+ 只能用指针来获取所需的效果

### 18.4.2 使用类型定义来简化声明

```c
int *(*x[10])(void)
```

为了让 `x` 的类型更容易理解，使用下面一系列的类型定义：

```c
typedef int *Fcn(void);
typedef Fcn *Fcn_ptr;
typedef Fcn_ptr Fcn_ptr_array[10];
Fcn_ptr_array x;
```

## 18.5 初始化式

> 声明变量时为他们指定初始值
>
> 声明符后面书写符号=，然后跟上初始化式
>
> 声明中的符号=和赋值运算符不一样

额外规则

+ 具有**静态存储期限**的变量初始化式必须是常量
+ 变量具有**自动存储期限**，初始化式不需要是常量
+ 包含在花括号中的数组、结构或者联合的初始化式必须只包含常量表达式，不允许有变量或函数调用
  + C99 中，仅当变量具有静态存储期限才有此限制
+ 自动类型的结构或者联合的初始化式可以是另一个结构或联合

**未初始化的变量**

+ 自动存储期限的变量没有默认的初始值
+ 静态存储期限的变量默认情况下的值为零，基于类型的正确初始化

## 18.6 内联函数

函数额外开销：调用函数和从函数返回所需的工作量

避免函数额外开销

+ 带参数的宏（14.3 节）
+ 创建**内联函数**（inline function）

>  并不是强制，只是建议

### 18.6.1 内联定义

```c
inline double average(double a, double b) {
  return (a + b) / 2;
}
```

试图在别的文件中调用 `average` 是错误的，因为他的定义是内联定义，但是他又有外部链接

1. 在函数定义中增加 `static` 

```c
static inline double average(double a, double b) {
  return (a + b) / 2;
}
```

2. 为 `average` 提供外部定义
   1. 将该函数重写一遍（不使用 `inline`）
   2. 将 `average` 的内联定义放入头文件，再创建与之匹配的源文件，任何一个需要调用 `average` 函数的文件只需要简单包含头文件即可。

average.h

```c
#ifndef AVERAGE_H
#define AVERAGE_H

inline double average(double a, double b) {
  return (a + b) / 2;
}

#endif
```

average.c

```c
#include "average.h"

extern double average(double a, double b);
```

> average.h 包含了 `average` 的内联定义；
>
> average.c 包含了 `average` 的原型；
>
> 由于使用了 `extern` 关键字，因此 average.h 中的 `average` 的定义在 average.c 中被认为是外部定义

### 18.6.2 对内联函数的限制