# 小破站高质量面试题：MySQL 夺命连环50问（高频面试题及解析）

> https://www.bilibili.com/video/BV1ta411C7xq

[B+🌲演示](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

[MySQL Innodb 文档](https://dev.mysql.com/doc/internals/en/innodb-page-overview.html)

[toc]

**问：innodb 下默认一页有多大**

答：16384，约等于 16 KB

```mysql
mysql> show global status like 'Innodb_page_size';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| Innodb_page_size | 16384 |
+------------------+-------+
1 row in set (0.00 sec)

mysql> select 16384/1024;
+------------+
| 16384/1024 |
+------------+
|    16.0000 |
+------------+
1 row in set (0.00 sec)
```

**问：页起到什么作用**

答：innodb 在存取数据时，最小的一个单位就是一页

### **页的结构**

来自官网：

+ Fil Header

+ Page Header

+ The Infimum and Supremum Records]

+ **User Records**

+ Free Space

+ **Page Directory**

+ Fil Trailer

**表结构**

```mysql
create table `t1` (
	`a` int primary key,
    `b` int,
    `c` int,
    `d` int,
    `e` varchar(20)
) engine=InnoDB;

mysql> show index from t1\G;
*************************** 1. row ***************************
        Table: t1
   Non_unique: 0
     Key_name: PRIMARY
 Seq_in_index: 1
  Column_name: a
    Collation: A
  Cardinality: 0
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: BTREE
      Comment: 
Index_comment: 
      Visible: YES
   Expression: NULL
1 row in set (0.00 sec)
```

> 索引有主键索引，索引类型在 MySQL 下还是认为是 B 树（实际上是 B+ 树）

插入数据：

```mysql
insert into t1 values(4,3,1,1,'d');
insert into t1 values(1,1,1,1,'a');
insert into t1 values(8,8,8,8,'h');
insert into t1 values(2,2,2,2,'b');
insert into t1 values(5,2,3,5,'e');
insert into t1 values(3,3,2,2,'c');
insert into t1 values(7,4,5,5,'g');
insert into t1 values(6,6,4,4,'f');
```

执行一下查询：

```mysql
mysql> select * from t1;
+---+------+------+------+------+
| a | b    | c    | d    | e    |
+---+------+------+------+------+
| 1 |    1 |    1 |    1 | a    |
| 2 |    2 |    2 |    2 | b    |
| 3 |    3 |    2 |    2 | c    |
| 4 |    3 |    1 |    1 | d    |
| 5 |    2 |    3 |    5 | e    |
| 6 |    6 |    4 |    4 | f    |
| 7 |    4 |    5 |    5 | g    |
| 8 |    8 |    8 |    8 | h    |
+---+------+------+------+------+
8 rows in set (0.00 sec)
```

> selet 语句没有加入任何的 order by 条件，并且插入时也是乱序插入，为何查出来的顺序还是已经排好序了？

可以理解页为一个对象：

```java
class Page {
  ...
  List<UserRecord> list;
}
```

当 Page 对象满 16KB 后，再序列化到磁盘

插入时在 list 中对各个记录按照主键进行排序（why）

> `select * from t1 where a=3`

由于 `list` 在查询时要遍历，效率低，因此 `Page` 中还引入了**页目录**

```
目录

第 1 章 aaa......1
第 2 章 bbb......14
第 3 章 ccc......27
```

将排序好的 `list` 分组，页目录中存储每个分组**起始序号**（主键）——比对上面目录，这样根据主键查找时先读目录确定分组，再去分组中遍历

<img src="/Users/daydaylw3/Pictures/typora/image-20220507015144490.png" alt="image-20220507015144490" style="zoom:60%;" />

> 思考如果没有页目录，`select * from a = 3` 、`select * from a = 300` 时，该如何遍历
>
> 有页目录呢？

**存满 8 条数据之后**

<img src="/Users/daydaylw3/Pictures/typora/image-20220507015824053.png" alt="image-20220507015824053" style="zoom:67%;" />

> 注意 next 指针

```mysql
select * from t1 where a=6;
```

上面这条 sql 会如何搜索？

倘若不止 2 页，而是有更多的页，而这时如果执行 `select * from t1 where a = 60000`，sql 会如何搜索？（其实本质上页与页之间还是链表，要遍历也只能一页接一页遍历）

**如何解决以上问题？**

类似于目录优化的逻辑，新开一页，**只保存各个页的最小的页目录**（这样可以存很多页的页目录）

```
假设主键为 int 类型（4B 大小）
一个目录指针大小为 6B，则总共为 10B
16KB / 10B = 1638页
```

新开的这个页可以保存 1638 个页的页目录，这时候再去查`a=60000`也能瞬间定位到时哪一页

**问：主键为 int，两层 B+树可以存多少条数据？**

```
假设一条数据大小为 1KB，则
1638 * (16KB / 1KB) = 26208条
```

**问：假若是 3 层 B+树？**

```
1638 * 1638 * (16KB / 1KB) = 42928704条
```

**问：倘若主键不是 int，而是 bigint？**

```
则 16KB / 10B 这儿的 10B 要修改
```

### 主键索引，聚集索引、聚簇索引

![image-20220507022140046](/Users/daydaylw3/Pictures/typora/image-20220507022140046.png)

上面部分叫索引页，下面部分叫数据页

>  思考一下，执行 `select * from a=6`，该如何查？
>
> 执行 `select * from b=6`，该如何查？

可以想到 `a=6` 时，是从索引页从上往下搜比较快，这种叫**走索引**，而 `b=6`时，只能从数据页从左往右搜，这种就没有走索引，叫**全表扫描** 

```mysql
mysql> explain select * from t1 where a=6;
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.01 sec)

mysql> explain select * from t1 where b=6;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    8 |    12.50 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

> 第一条的 `type` 为 const，`key` 为 primary，第二条的 `type` 为 all

**问：a>6 能否走索引？**

可以走索引找到 `a=6` 的数据，然后返回后面所有的数据即可

```mysql
mysql> explain select * from t1 where a>6;
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t1    | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    2 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
```

> 同理 `a<6`

### 联合索引

[联合索引](https://www.bilibili.com/video/BV1ta411C7xq?p=6&t=81.4)

```mysql
create index idx_t1_bcd on t1(b, c, d);
```

以上会将表中的记录以 `b,c,d` 三列进行排序（比如先比较 b，再比较 c，在比较 d）

<img src="/Users/daydaylw3/Pictures/typora/image-20220507124623992.png" alt="image-20220507124623992" style="zoom:67%;" />

<img src="/Users/daydaylw3/Pictures/typora/image-20220507125201906.png" alt="image-20220507125201906" style="zoom:67%;" />

> 可以注意到每个页目录存储的是 `bcd` 三列
>
> 思考一下到底应该是图 1 还是图 2 呢？

可以注意到如果是以图 1 来存储 `idx_t1_bcd`，在**数据页**会有一份额外的数据（冗余，且更新的话又要更新 `idx_t1_bcd` 的数据页，也要更新主键索引的数据页）。

> 但是如果是以图 2 来存储，倘若要执行 `select * from t1 where b=1, c=1, d=1`，那么通过 `idx_t1_bcd` 索引如何找到数据？

为了解决上面的问题，则在 `idx_t1_bcd` 索引的数据页中存储主键值，查找的时候

1. 根据 `idx_t1_bcd` 索引找到了主键值
2. 用主键值再去**主键索引**中找到对应的数据页中的数据

上面这种通过**联合索引**再去**主键索引**中找到数据的方式叫 **“回表”**

<img src="/Users/daydaylw3/Pictures/typora/image-20220507124346035.png" alt="image-20220507124346035" style="zoom:67%;" />

> 倘若执行 `select * from t1 where c=1 and d=1 and b=1`，能走索引吗？
>
> 那 `select * from t1 where c=1 and d=1`，能走索引吗？
>
> 最左前缀原则？

答：第一条能走，虽然 bcd 的顺序乱了，但是因为给了 `idx_t1_bcd` 索引中最左的列，所以能走`idx_t1_bcd` 索引（对着上图想象一下如何从上到下根据索引来比较）

第二条不能走，由于没有给出 `b` 列的数据，而 `idx_t1_bcd` 索引是先根据 `b` 来排序，再根据另外两列来排的（依然是对着上图想象一下如何走索引）

```mysql
mysql> explain select * from t1 where c=1 and d=1 and b=1;
+----+-------------+-------+------------+------+---------------+------------+---------+-------------------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key        | key_len | ref               | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------------+---------+-------------------+------+----------+-------+
|  1 | SIMPLE      | t1    | NULL       | ref  | idx_t1_bcd    | idx_t1_bcd | 15      | const,const,const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------------+---------+-------------------+------+----------+-------+
1 row in set, 1 warning (0.02 sec)

mysql> explain select * from t1 where c=1 and d=1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    8 |    12.50 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
```

**思考 `select * from t1 where b=1 and d=1` 能否走索引？**

答：应该是能的，因为 `idx_t1_bcd` 索引是先根据 `b` 来排序，虽然缺了 `c`，但是还可以用 `b` 匹配一下

```mysql
mysql> explain select * from t1 where b=1 and d=1;
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-----------------------+
| id | select_type | table | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra                 |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-----------------------+
|  1 | SIMPLE      | t1    | NULL       | ref  | idx_t1_bcd    | idx_t1_bcd | 5       | const |    1 |    12.50 | Using index condition |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-----------------------+
1 row in set, 1 warning (0.33 sec)
```

> 注意到 `Extra` 列的值为 `Using index condition`，也就是常说的**索引下推**
>
> 思考一下，上面的 sql 语句中，d=1 在走索引的时候是否有用到？

innodb 根据（1*1）去搜索引，找到左下角的 Page 页，里面有两条数据，假设里面还有一条记录索引值是（122）

+ 没有用到 `d=1`：innodb 拿到 `b=1` 的两条记录（111）（122），回表去主键索引中找到两条记录，再去匹配 `d=1` 的条件，找到唯一一条记录（111）
+ 有用到 `d=1`：innodb 直接通过 `b=1 and d=1` 筛选出来一条记录（111），回表去主键索引中找到一条记录

> 其实因为用到了**索引下推**，说明 innodb 已经在回表前，根据索引的条件进行了一定的筛选（筛选 `d=1 的记录）
>
> *索引下推也是 MySQL5.6 版本之后才有的优化

#### 范围查找导致索引失效

**思考 `select * from t1 where b>1 ` 能否走索引？**

**那 `select * from t1 where b>6` 能否走索引？**

**那 `select c, d from t1 where b>1` 能否走索引？**

答：第一个问题，虽然可以通过走索引找到 Page 页中的记录，但是数据页中记录是不完整的，他只记录了主键 a，以及 `bcd` 字段，还缺失了 `e` 字段，因此还需要回表去查记录，而根据图 3 可以看到有 7 条记录符合条件，因此要回表找 7 次，效率还不如直接全表扫描。

第二个问题，同第一个问题类似，但是因为只有 1 条记录符合条件，只需要回表 1 次，所以走索引效率高，可以走索引。

> 从问题一和二可以看出来，走联合索引还是全表扫描，其实是一个择优的过程，如果回表多次效率还不如全表扫描，那么就会全表扫描，如果能确定回表的次数不多，还是可以走索引的

第三个问题，因为索引数据页中存储了 `abcd` 字段，而 sql 只要 `cd` 字段，那么完全不用回表查询记录，所以虽然和问题一一样有 7 条记录符合条件，但是由于不用回表，完全可以走索引

```mysql
mysql> explain select * from t1 where b>1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t1    | NULL       | ALL  | idx_t1_bcd    | NULL | NULL    | NULL |    7 |    12.50 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from t1 where b>6;
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | t1    | NULL       | range | idx_t1_bcd    | idx_t1_bcd | 5       | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.01 sec)

mysql> explain select c, d from t1 where b>1;
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | t1    | NULL       | range | idx_t1_bcd    | idx_t1_bcd | 5       | NULL |    7 |   100.00 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
```

> 可以看到第三条查询的 `Extra` 列有一个 `Using index` 的情况，说明**覆盖索引**

**思考 `select b from t1` 能否走索引？会不会全表扫描？**

**那 `select c from t1` 呢？**

答：因为没有 `where` 条件，所以只能从数据页的最左向右进行扫描，但是现在有两个选择，是从主键索引的数据页扫描？还是从联合索引的数据页扫描（联合索引的数据页也有 `b` 字段的数据）？

因为主键索引的数据页存储的是整个记录，联合索引的数据页只存了 `abcd` 字段，所以联合索引的数据页一页应该能存更多条的记录 -> 所以也应该会有更少的数据页 -> 所以从左往右扫描也会扫描更少的数据页，因此也可以使用联合索引全表扫描（类似的扫描逻辑）。

第二个问题和第一个问题同理

```mysql
mysql> explain select b from t1;
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_t1_bcd | 15      | NULL |    8 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)

mysql> explain select c from t1;
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t1    | NULL       | index | NULL          | idx_t1_bcd | 15      | NULL |    8 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

**思考 `select * from t1 order by b,c,d` 能否走索引？**

**那 `select a,b,c,d from t1 order by b,c,d` 呢？**

**那 `select a,b,c,d from t1 order by b,c` 呢？**

答：执行第一条 sql 语句，innodb 有两个选择：

+ 走 `idx_t1_bcd` 索引（索引数据页全表扫描），好处是不需要排序（因为 order by bcd），但是因为缺失了 `e` 字段，所以需要回表
+ 全表扫描，好处是不需要回表，但是需要进行排序（在内存中）

这两个选择 innodb 会择优而选，全表扫描虽然要排序，但是索引要回表啊！权衡之下还是选择使用 “全表扫描”

那么第二第三个问题呢？因为不用回表，所以明显使用索引会更好！

### MySQL 中的数据类型转换有哪些要注意

先给 `e` 字段建索引

```mysql
create index idx_t1_e on t1(e);
```

![image-20220508144948379](/Users/daydaylw3/Pictures/typora/image-20220508144948379.png)

**问 `select * from t1 where a = 1` 能否走索引？**

**那 `select * from t1 where e = '1'` 呢？**

答：都能

**`select * from t1 where a = '1'` 能否走索引？**

**那 `select * from t1 where e = 1` 呢？**

答：先思考这个问题：`select 'a' = 0` 的结果是什么？`select 'b' = 0` 的结果又是什么？

```mysql
mysql> select 'a' = 0;
+---------+
| 'a' = 0 |
+---------+
|       1 |
+---------+
1 row in set, 1 warning (0.02 sec)

mysql> select 'b' = 0;
+---------+
| 'b' = 0 |
+---------+
|       1 |
+---------+
1 row in set, 1 warning (0.00 sec)
```

结果为 `1` 说明结果为真；直接说结论：在等式两边的类型为一个数字类型一个字符类型时，MySQL 都会尝试**将字符类型转换为数字**，转换的规则为：

+ 字符为数字：转换为对应的数字
+ 字符非数字：转换为 `0`

```mysql
mysql> select '123' = 123;
+-------------+
| '123' = 123 |
+-------------+
|           1 |
+-------------+
1 row in set (0.00 sec)

mysql> update t1 set b=0 where a=1;
Query OK, 1 row affected (0.04 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from t1 where b='c';
+---+------+------+------+------+
| a | b    | c    | d    | e    |
+---+------+------+------+------+
| 1 |    0 |    1 |    1 | a    |
+---+------+------+------+------+
1 row in set, 1 warning (0.00 sec)
```

> 可以看到搜索条件为 `b='c'` 将 `b=0` 的行搜索出来了，也印证上面的结论

这时候再回到上面的问题，搜索条件为 `a = '1'`，会将 `'1'` 转换为 `0`， 所以会走主键索引；

那么搜索条件为 `e = '1'` 呢？他会记录中所有行的将 `e` 字段都转换为数字（规则还是上面讲的规则），再进行比较！（OMG）

+ 倘若走索引，则索引值都要进行转换，有可能导致索引前后转换的排序失效（比如 `'a' > '1'`，但是转换后 `0 < 1`）；将所有的索引 load 到内存中转换再排序再检索，成本过大，还不如全表扫描

```mysql
mysql> explain select * from t1 where a='1';
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.02 sec)

mysql> explain select * from t1 where e=1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t1    | NULL       | ALL  | idx_t1_e      | NULL | NULL    | NULL |    8 |    12.50 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 3 warnings (0.02 sec)
```

> 其实对比两条 sql，都进行了类型转换，但是前者是针对**值**，后者是针对了**字段**

直接说结论，对于**字段**的操作（比如类型转换，数值变化），都会导致索引失效，不走索引

```mysql
mysql> explain select * from t1 where a+1='1';
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    8 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.04 sec)
```

> 就是因为对 `a` 字段进行了 `+1` 的操作，就导致未走索引

### 总结

1. B 树和 B+ 树的区别？
2. Innodb 中的 B+ 树的特点
3. 什么是 Innodb 中的 Page？
4. Innodb 中的 B+ 树是怎样产生的？
5. 什么是聚簇索引？
6. Innodb 是如何支持范围查找能走索引的？
7. 什么是联合索引？对应的 B+ 树如何生成？
8. 什么是最左前缀原则？
9. 为什么要遵守最左前缀原则才能利用到索引？
10. 什么是索引条件下推？
11. 什么是覆盖索引？
12. 有哪些情况会导致索引失效？

