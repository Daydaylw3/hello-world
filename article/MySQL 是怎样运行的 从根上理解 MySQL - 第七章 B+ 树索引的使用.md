[toc]

------

## 7.1 B+ 树索引示意图的简化

```mysql
mysql> CREATE TABLE single_table (
    -> id INT NOT NULL AUTO_INCREMENT,
    -> key1 VARCHAR(100),
    -> key2 INT,
    -> key3 VARCHAR(100),
    -> key_part1 VARCHAR(100),
    -> key_part2 VARCHAR(100),
    -> key_part3 VARCHAR(100),
    -> common_field VARCHAR(100),
    -> PRIMARY KEY (id),
    -> KEY idx_key1 (key1),
    -> UNIQUE KEY uk_key2 (key2),
    -> KEY idx_key3 (key3),
    -> KEY idx_key_part(key_part1, key_part2, key_part3)
    -> ) Engine=InnoDB CHARSET=utf8;
Query OK, 0 rows affected, 1 warning (0.35 sec)
```

插入 10000 条记录

## 7.2 索引的代价

> 它在空间和时间上都会"拖后腿”

+ 空间上的代价
+ 时间上的代价
  + 每当对表中的数据进行增删改操作时，都需要修改各个B+ 树索引。存储引擎需要额外的时间进行页面分裂、页面回收等操作，以维护节点和记录的排序。
  + 在执行查询语句前， 首先要生成一个执行计划。在生成执行计划时需要计算使用不同索引执行查询时所需的成本，最后选取成本最低的那个索引执行查询，时如果建了太多索引，可能会导致成本分析过程耗时太多，从而影响查询语句的执行性能.

## 7.3 应用 B+ 树索引

### 7.3.1 扫描区间和边界条件

**全表扫描**：扫描表中的所有记录，判断每一条记录是否符合搜索条件

> 可以利用B+ 树查找索引列值等于某个值的记录，这样可以明显减少需要扫描的记录数量

**扫描区间**：待扫描记录的值所在的区间

**边界条件**：形成这个扫描区间的搜索条件

> 对于全表扫描来说， 相当于扫描描区间是（-∞，+∞）

```mysql
SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);
```

> 该查询的搜索条件涉及key2 列，正好为key2 列建立了uk_key2 索引

如果使用uk_key2 索引执行这个查询，则相当于从下面的3 个扫描区间中获取二级索引记录.

+ [1438, 1438]
+ [6328, 6328]
+ [38, 79]

**单点扫描区间**：只包含一个值的扫描区间

**范围扫描区间**：包含多个值的扫描区间

> 在使用某个索引执行查询时，关键的问题就是通过搜索条件找出合适的扫描区间，然后再到对应的B+ 树中扫描索引列值在这些扫描区间的记录

+ 对于每个扫描区间来说，仅需要通过B+ 树定位到该扫描区间中的第一条记录，然后就可以沿着记录所在的单向链表向后扫描，直到某条记录不符合形成该扫描区间的边界条件为止.

#### 1. 所有搜索条件都可以生成合适的扫描区间的情况

> 需要补上

#### 2. 有的搜索条件不能生成合适的扫描区间的情况

> 需要补上

#### 3. 从复杂的模索条件中找出扫描区间

```mysql
mysql> explain select * from single_table where 
    -> (key1 > 'xyz' and key2 = 748) or
    -> (key1 < 'abc' and key1 > 'lmn') or
    -> (key1 like '%suf' and key1 > 'zzz' and (key2 < 8000 or common_field='abc'));
+----+-------------+--------------+------------+-------+------------------+----------+---------+------+------+----------+------------------------------------+
| id | select_type | table        | partitions | type  | possible_keys    | key      | key_len | ref  | rows | filtered | Extra                              |
+----+-------------+--------------+------------+-------+------------------+----------+---------+------+------+----------+------------------------------------+
|  1 | SIMPLE      | single_table | NULL       | range | uk_key2,idx_key1 | idx_key1 | 303     | NULL |    1 |   100.00 | Using index condition; Using where |
+----+-------------+--------------+------------+-------+------------------+----------+---------+------+------+----------+------------------------------------+
1 row in set, 1 warning (0.29 sec)
```

>  不能形成合适扫描区间的搜索条件暂时移除掉：把它们替换为TRUE

**假设使用 idx_key1 执行查询**

+ 上面的查询中有关key2 和common_field 列的搜索条件不能形成合适的扫描区间
+ key1 like '%suf' 形成的扫描区间是（-∞，+∞）

```mysql
(key1 > 'xyz') or (key1 < 'abc' and key1 > 'lmn') or (key1 > 'zzz')
```

再次简化

```mysql
(key1 > 'xyz') or (key < 'abc' and key1 > 'lmn')
```

> (key < 'abc' and key1 > 'lmn') 永远为 FALSE

```mysql
key1 > 'xyz'
```

则对应的扫描区间就是( 'xyz'， +∞)。是需要把满足key1 > 'xyz' 条件的所有二级索引记录都取出来，针对获取到的每一条二级索引记录，都要用它的主键值再执行回表操作，在得到完整的用户记录之后再使用其他的搜索条件进行过滤

**假设使用 uk_key2 执行查询**

+ 有关 key1 和 common_field 的搜索条件都需要被替换掉

```mysql
(key2 = 748) or (key2 < 8000 or TRUE)
```

再简化就是

```mysql
key2 = 748 or TRUE
TRUE
```

扫描区间为（-∞，+∞），还要进行回表

> 在使用idx_key1 执行上述查询时，搜索条件keyl LIK卫'%su f' 比较特殊.虽然它不能作为形成扫描区间的边界条件， 但是idx_key1 的二级索引记录是包含key1 列的，因此，我们可以先判断获取到的二级索引记录是否符合这个条件.如果符合再执行回表操作，如果不符合就不执行回农操作了.这样可能减少因回农操作而带来的性能损耗，这种优化方式称为**索引条件下推**

#### 4. 使用联合索引执行查询时对应的扫描区间

```mysql
select * from single_table where key_part1 < 'b' and key_part2 = 'a';
```

扫描区间是：[-∞, 'b')，形成扫描区间的条件是 key_part1 < 'b'，和 key_part2 = 'a' 无关

```mysql
select * from single_table where key_part1 <= 'b' and key_part2 = 'a';
```

对于符合 key_part1 < 'b' 的二级索引记录来说，并不是按照 key_part2  列排序的；但是对于 key_part1 = 'b' 的二级索引记录来说，是按照 key_part2  列排序的；那么当二级索引记录的 key_part1 列值为 'b' 时，可以通过 key_part2 = 'a' 条件减少需要扫描的二级索引记录范围

形成扫描区间：`((-∞, -∞), ('b', 'a')]`

### 7.3.2 索引用于排序

**文件排序（filesort）**：在内存或者磁盘中进行排序的方式。把记录加载到内存中，然后再用一些排序算法在内存中对这些记录进行排序.有时查询的结果集可能太大以至于无法在内存中进行排序，此时就需要暂时借助磁盘的空间来存放中间结果，在排序操作完成后再把排好序的结果集返回

> 如果 ORDER BY 子句中使用了索引列，就有可能省去在内存或磁盘中排序的步骤

```mysql
select * from single_table order by key_part1, key_part2, key_part3 limit 10;
```

#### 1. 使用联合索引进行排序时的注意事项

+ ORDER BY 子句后面的列的顺序也必须按照索引列的顺序给出
+ ORDER BY key_part1 和ORDER BY key_part1, key_part2 这些仅对联合索引的索引列中左边连续的列进行排序的形式，也是可以利用B+ 树索引的
+ 当联合索引的索引列左边连续的列为常量时，也可以使用联合索号|对右边的列进行排序

#### 2. 不可以使用索引迸行排序的几种情况

1) ASC 、DESC 混用：要求各个排序列的排序规则是一致的，也就是要也各个列都是按照ASC (升序)规则排序， 要么都是按照DESC (降序〉规则排序（降序排序还是要比升序排序复杂一点）

   > MySQL 8.0 引入了一种称为 Descending lndex 的特性，可以支持ORDER BY 子句中ASC、DESC 混用的情况

2) 排序列包含非同一个索引的列

   ```mysql
   select * from single_table order by key1, key2 limit 10;
   ```

3) 排序列是某个联合索引的索引列， 但是这些排序列在联合索引中并不连续

   ```mysql
   select * from single_table order by key_part1, key_part3 limit 10;
   ```

4) 用来形成扫描区间的索引列与排序列不同

   ```mysql
   select * from single_table where key1 = 'a' order by key2 limit 10;
   ```

   搜索条件 `key1 ='a'` 用来形成扫描区间，也就是在使用 `idx_key1` 执行该查询时，只需要扫描 key1 的值为 'a' 的二级索引记录即可，此时无法使用 `uk_key2` 执行上述查询

5) 排序列不是以单独列名的形式出现在 ORDER BY 子句中（不能是修饰过的）

### 7.3.3 索引用于分组

```mysql
select key_part1, key_part2, key_part3, count(*) from single_table group by key_part1, key_part2, key_part3;
```

这个查询语句相当于执行了3 次分组操作

+ 先按照key_part1 值把记录进行分组， key_part1 值相同的所有记录划分为一组
+ 将 key_part1 值相同的每个分组中的记录再按照key_part2的值进行分组， 将 key_part2 值相同的记录放到一个小分组中
+ 同理分 key_part3 值相同的组

如果没有 idx_key_part 索引，就得建立一个用于统计的临时表，在扫描聚簇索引的记录时将统计的中间结果填入这个临时表。当扫描完记录后， 再把临时表中的结果作为结果集发送给客户端

如果有了 idx_key_part 索引，，恰巧这个分组顺序又与 idx_key_part 的索引列的顺序是一致的，可以直接使用 idx_key_part 索引进行分组，而不用再建立临时表了

> 与使用B+ 树索引进行排序差不多， 分组列的顺序也需要与索引列的顺序一致；可以只使用索引列中左边连续的列迸行分组

## 7.4 回表的代价

```mysql
select * from single_table where key1 > 'a' and key1 < 'c';
```

可以选择下面这两种方式来执行.

+ 全表扫描

+ 使用 idx_key1 索引

  扫描区间( 'a', 'c' )中的二级索引记录对应的 id 值的大小是毫无规律的， 我们每读取一条二级索引记录，就需要根据该二级索引记录的 id 值到聚簇索引中执行回表操作. 如果对应的聚簇索引记录所在的页面不在内存中，就需要将该页面从磁盘加载到内存中，要读取很多 id 值并不连续的聚簇索引记录，因此会造成大量的随机 `I/O`

  需要执行回表操作的记录越多， 使用二级索引进行查询的性能也就越低

> 某些查询宁愿使用全表扫描也不使用二级索引

那么在执行查询时， 什么时候采用全表扫描， 什么时候使用二级索引+回表的方式呢？

> 是**查询优化器**应该做的工作

查询优化器会事先针对表中的记录计算一些统计数据，然后再利用这些统计数据或者访问表中的少量记录来计算需要执行回表操作的记录数

+ 需要执行回表操作的记录数越多，越倾向于使用全表扫描
+ 反之则倾向于使用二级索引+回表的方式

可以给查询语句指定 LIMIT 子句来限制查询返回的记录数， 这可能会让查询优化器倾向于选择使用二级索引+回表的方式进行查询

## 7.5 更好地创建和使用索引

### 7.5.1 只为用于搜索、排序或分组的列创建索引

仅出现在查询列表中的列就没必要建立索引了

### 7.5.2 考虑索引列中不重复值的个数

某个扫描区间中包含的二级索引记录数量越多， 就会导致回表操作的代价越大

需要考虑该列中包含过多重复值，在通过二级索引+回表的方式执行查询时，有可能执行太多次回表操作

### 7.5.3 索引列的类型尽量小

这个建议对于袤的主键来说更加适用，因为不仅聚簇索引会存储主键值，其他所有的二级索引的节点都会存储一份记录的主键值. 如果主键使用更小的数据类型，也就意味着能节省更多的存储空间

### 7.5.4 为列前缀建立索引

只将字符串的前几个字符存放到索引中，也就是说在二级索引的记录中只保留字符串的前几个字符

```mysql
alter table single_table drop index idx_key1;
alter table single_table add index idx_key1(key1(10));
```

当列中存储的字符串包含的字符较多时，这种为列前缀建立索引的方式可以明显减少索引大小

> 但是只为列前缀建立索引的方式无法支持使用索引进行排序的需求

```mysql
select * from single_table order by key1 limit 10;
```

### 7.5.5 覆盖索引

>  为了彻底告别回表操作带来的性能损耗，建议最好在查询列表中只包含索引列

```mysql
select key1, id from single_table where key1 > 'a' and key1 < 'c';
```

> 可以直接从获取到的二级索引记录中读出key1 列和 id 列的值，而不需要再通过 id 值到聚簇索引中执行团表操作

**覆盖索引**：索引中已经包含所有需要读取的列的查询方式

### 7.5.6 让索引列以列名的形式在搜索条件中单独出现

### 7.5.7 新插入记录时主键大小对效率的影响

如果新插入记录的主键值忽大忽小，就比较麻烦了

假设某个数据页存储的聚簇索引记录已经满了， 它存储的主键值在 1 - 100 之间。

![image-20220512014742008](/Users/daydaylw3/Pictures/typora/image-20220512014742008.png)

此时，如果再插入一条主键值为9 的记录

![image-20220512014750900](/Users/daydaylw3/Pictures/typora/image-20220512014750900.png)

可这个数据页已经满了，我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的页中。

页面分裂意味着性能损耗

### 7.5.8 冗余和重复索引

应该避免

## 7.6 总结

+ B+ 树索引在空间和时间上都有代价
+ 索引可以用于减少需要扫描的记录数量，也可以用于排序和分组
+ 在使用索引来减少需要扫描的记录数量时，应该先找到使用该索引执行查询时对应的扫描区间和形成该扫描区间的边界条件
+ 创建和使用索引时注意事项

------

[toc]