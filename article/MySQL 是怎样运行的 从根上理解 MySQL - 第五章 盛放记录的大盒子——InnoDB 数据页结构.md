[toc]

------

## 5.1 不同类型的页简介

> 存放表空间头部的页、存放 `Change Buffer` 的页、存放 `INODE` 信息的页、存放 `undo` 日志的页

**索引（INDEX）页**：存放表中记录数据的页，暂时称为数据页

## 5.2 数据页结构快览

可以划分 7 个部分

<img src="/Users/daydaylw3/Pictures/typora/image-20220511010712619.png" alt="image-20220511010712619" style="zoom:80%;" />

> 有的部分占用的字节数是确定的，有的是不确定的

| 名称                 | 中文名                     | 占用空间大小（字节 | 简单描述               |
| -------------------- | -------------------------- | ------------------ | ---------------------- |
| `File Header`        | 文件头部                   | 38                 | 页的一些通用信息       |
| `Page Header`        | 页面头部                   | 56                 | 数据页专有的一些信息   |
| `Infimum + Supremum` | 页面中的最小记录和最大记录 | 26                 | 两个虚拟的记录         |
| `User Records`       | 用户记录                   | 不确定             | 用户存储的记录内容     |
| `Free Space`         | 空闲空间                   | 不确定             | 页中尚未使用的空间     |
| `Page Directory`     | 页目录                     | 不确定             | 页中某些记录的相对位置 |
| `File Trailer`       | 文件尾部                   | 8                  | 校验页是否完整         |

## 5.3 记录在页中的存储

我们自己存储的记录会按照指定的行格式存储到 `User Records` 部分

一开始生成页时并没有 `User Records`，每插入一条记录，都会从 `Free Space` 申请一个记录大小的空间并划分到 `User Records`

当 `Free Space` 全部被 `User Records` 替代之后，意味着该页用完了，有新的记录插入就需要申请新的页

### 5.3.1 记录头信息的秘密

```mysql
mysql> CREATE TABLE page_demo (
    -> c1 INT,
    -> c2 INT,
    -> c3 VARCHAR(10000),
    -> PRIMARY KEY(c1)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
Query OK, 0 rows affected (0.40 sec)
```

![image-20220511011607125](/Users/daydaylw3/Pictures/typora/image-20220511011607125.png)

向 `page_demo` 插入记录

```mysql
mysql> INSERT INTO page_demo VALUES (1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
Query OK, 4 rows affected (0.19 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

![image-20220511011927568](/Users/daydaylw3/Pictures/typora/image-20220511011927568.png)

#### **delete_flag**

被删除的记录会将 `delete_flag` 置 1，可记录还真实留在磁盘上，不从磁盘上移除是因为要在磁盘上重新排列其他的记录，会带来性能消耗。

所有被删掉的记录会组成一个垃圾链表，记录在这个链表中占用的空间称为可重用空间，之后如果有新的记录插入表，就有可能覆盖掉被删除的记录占用的存储空间

#### **min_rec_flag**

B+ 树每层非叶子节点中的最小的目录项记录都会添加该标记

现在只需要知道自己插入的 4 条记录的 min_rec_flag 值都是 0，意味着它们都不是 B+ 树非叶子节点中的最小的目录项记录

#### **n_owned**

#### **heap_no**

向表中插入的记录从本质上来说都是放到数据页的 `User Records` 部分，这些记录一条一条地亲密无间地排列着

![image-20220511012619097](/Users/daydaylw3/Pictures/typora/image-20220511012619097.png)

`InnoDB` 把记录一条一条亲密无间排列的结构称之为堆，为了方便管理，把一条记录（`delete_flag` 可以为 1）在堆中的相对位置称之为 `heap_no`

插入的 4 条记录的 `heap_no` 属性值分别是 `2、3、4、5`，`0` 和 `1` 是 `InnoDB` 自动动给每个页里面加了两条记录，有时候也称为伪记录或者虚拟记录。

一条代表页面中的最小记录（`Infimum`），一条代表页面中的最大记录（`Supremeum`）；这两条伪记录也算作堆的一部分（最靠前）

.对于一条完整的记录来说，比较记录的大小就是比较主键的大小

无论我们向页中插入了多少条记录，InnoDB 的大叔都**规定**，任何用户记录都比Infimum 记录大，任何用户记录都比Supremu皿记录小.

Infirnum 和Supremum 这两条记录的构造十分简单，都是由5 字节大小的记录头信息和8字节大小的一个固定单词组成的

<img src="/Users/daydaylw3/Pictures/typora/image-20220511125508106.png" alt="image-20220511125508106" style="zoom:50%;" />

由于lnfimum 和Supremum :这两条记录是设计InnoDB 的大叔默认创建的记录， 为了与用户自己插入的记录进行区分，我们就不把它们存放在页的User Records 部分，而是单独放在一个称为Infimum + Supremum 的部分，

<img src="/Users/daydaylw3/Pictures/typora/image-20220511125759005.png" alt="image-20220511125759005"  />

lnfimum 记录和 Supremum 记录的 heap_no 值分别是0 和1.也就是说它们在堆中的相对位置最靠前

> 堆中记录的 heap_no 值在分配之后就不会发生改动了，即使之后删除了堆中的某条记录， 这条被删除记录的 heap_no 值也仍然保持不变.

#### **record_type**

表示当前记录的类型

+ 0：普通记录
+ 1：B+ 树非页节点的目录项记录
+ 2：`infimum` 记录
+ 3：`Supremum` 记录

#### **next_record**

它表示从当前记录的真实数据到下一条记录的真实数据的距离.

如果该属性值为正数， 说明当前记录的下一条记录在当前记录的后面:

如果该属性值为负数，说明当前记录的下一条记录在当前记录的前面.

> 第l 条记录的next record 值为32. 意味着从第l 条记录的其实数据的地址处向后找32 字节便是下一条记录的真实数据
>
> 第4 条记录的next re∞rd 值为一11 1. 意味着从第4 条记录的真实数据的地址处向前找111 字节便是下一条记录的真实数据.

这其实就是个链衰，可以通过一条记录找到它的下一条记录

下一条记录指的是按照主键值由小到大的顺序排列的下一条记录

+ 规定Infimum 记录的下一条记录就是本页中主键值最小的用户记录，

+ 本页中主键值最大的用户记录的下一条记录就是Supremum 记录.

<img src="/Users/daydaylw3/Pictures/typora/image-20220511130109806.png" alt="image-20220511130109806" style="zoom:67%;" />

> 记录按照主键从小到大的顺序形成了一们单向链表. Supremum 记录的next record 值为O. 也就是说Supremurn 记录之后就没有下一条记录了， 这也意味着Supremum记录就是这个单向链表中的最后一个节点.

如果从表中删除一条记录， 这个由记录组成的单向链表也是会跟着变化

```mysql
mysql> DELETE FROM page_demo WHERE c1 = 2;
Query OK, 1 row affected (0.44 sec)
```

<img src="/Users/daydaylw3/Pictures/typora/image-20220511130310205.png" alt="image-20220511130310205" style="zoom:67%;" />

+ 第2 条记录并没有从存储空间中移除，而是把该条记录的deleted_ ß ag 值设置为1 ;
+ 第2 条记录的oext record 值变为O. 意味着该记录没有下一条记录了:
+ 第1 '条记录的next record 指向了第3 条记录:
+ Supremum 记录的o_owned 值从5 变成了4 .

> next record 这个指针为啥妾指向记录头信息和真实数据之间的位直呢?为啥不干脆指向整条记录的开头位置?

+ 这个位置刚刚好， 向左读取就是记录头信息，向右读取就是真实数据
+ 变长字体长度列表、NULL 列表中的信息都是逆序存放的， 这样可以使记录中位直靠前的字段和它们对应的字段长度信息在内存中的距离灵近， 这可能会提高高速缓存的命中卒.

> 主键值为2 的记录被删掉了， 但是却没有回收存储空间( 该记录的heap_no 也未发生改变) .如果我们再次把这条记录插入到表中， 会发生什么呢?

```mysql
mysql> INSERT INTO page_demo VALUES (2, 200, 'bbbb');
Query OK, 1 row affected (0.06 sec)
```

<img src="/Users/daydaylw3/Pictures/typora/image-20220511131357802.png" alt="image-20220511131357802" style="zoom:67%;" />

InnoDB 并没有因为新记录的插入而为官申请新的存储空间， 而是直接复用了原来被删除记录的存储空间.

## 5.4 Page Directory（页目录）

```mysql
SELECT * FROM page_demo WHERE c1 = 3;
```

InnoDB 的大叔也为我们的记录制作了一个类似的目录

1. 将所有正常的记录(包括Infimum 和Supremum 记录，但不包括已经移除到垃圾链表的记录)划分为几个组.
2. 每个组的最后一条记录(也就是组内最大的那条记录)相当于"带头大哥"组内其余的记录相当于"小弟”。“带头大哥”记录的头信息中的n_owned 属性表示该组内共有几条记录
3. 将每个组中最后一条记录（带头大哥）在页面中的地址偏移量单独提取出来，按顺序存储到靠近页尾部的地方，这个地方就是 `Page Directory`

页目录中的这些地址偏移量称为槽(Slot) ，每个槽占用2 字节.页目录就是由多个槽组成的.

> 一个正常的页面也就是16KB 大小，即16384 字节，而2 字节可以表示的地址偏移量范围是0-65535. 所以用2 字节表示一个槽足够了.

现在page_demo 表中正常的记录共有6 条， InnoDB 会把它们分成2 个组，第一组只有一个Infi mum 记录，第二组是剩余的5 条记录。2 个组就对应着2 个槽， 每个槽中存放每个组中最大的那条记录在页面中的地址偏移量

![image-20220511145201324](/Users/daydaylw3/Pictures/typora/image-20220511145201324.png)

+ 页目录部分中有2 个槽，也就意味着记录被分成了2 个组.槽1 中的值是112. 代表Supremum 记录在页面中的地址偏移量，槽0 中的值是99 . 代表Infimum 记录的地址偏移
+ 注意Infimum记录和Supremum 记录的头信息中的n_owned 属性.
  + Infimum 记录的n owned 值为1. 这表示以Infimum 记录为最后一个节点的这个分组中只有1 条记录， 也就是Infimum记录自身.
  + Suprem山刀记录的n owned 值为5 . 这表示以Supremum 记录为最后一个节点的这个分组中有5 条记录， 即除了Supremum 记录自身之外，还有我们插入的4 条记录.
+ 每个槽占用2 字节，按照对应记录的大小相邻分布.槽对应的记录越小，它的位置越靠近 File Trailer

![image-20220511150111165](/Users/daydaylw3/Pictures/typora/image-20220511150111165.png)

> InnoDB 的大叔对每个分组中的记录条数是有规定的对于Infimum 记录所在的分组只能有l 条记录， Supremum 记录所在的分组拥有的记录条数只能在1 - 8 条之间，剩下的分组中记录的条数范围只能是在4 - 8 条之间

1. 在初始情况下，一个数据页中只有Infimum 记录和Supremum 记录这两条，它们分属于两个分组.页目录中也只有两个槽，分别代表lnfimum 记录和S upremum 记录在页面中的地址偏移量.
2. 之后每插入一条记录， 都会从页目录中找到对应记录的主键值比待插入记录的主键值大并且差值最小的槽(从本质上来说，槽是一个组内最大的那条记录在页面中的地址偏移量，通过槽可以快速找到对应的记录的主键值) .然后把该糟对应的记录的n owned 值加 1，表示本组内又添加了一条记录， 直到该组中的记录数等于 8 个
3. 当一个组中的记录数等于8 后，再插入一条记录，会将组中的记录拆分成两个组，其中一个组中4 条记录，另一个5 条记录.这个拆分过程会在页目录中新增一个槽， 记录这个新增分组中最大的那条记录的偏移量.

```mysql
mysql> INSERT INTO page_demo VALUES (5, 500, 'eeee'), (6, 600, 'ffff'), (7, 700, 'gggg'), (8, 800, 'hhhh'), (9, 900, 'iiii'), (10, 1000, 'jjjj'), (11, 1100, 'kkkk'), (12, 1200, 'llll'), (13, 1300, 'mmmm'), (14, 1400, 'nnnn'), (15, 1500, 'oooo'), (16, 1600, 'pppp');
Query OK, 12 rows affected (0.24 sec)
Records: 12  Duplicates: 0  Warnings: 0
```

往表中添加了12 条记录，现在页中就一共有18 条记录了(包括Infimum 和Supremum 记录).这些记录被分成了5 个组

![image-20220511151353984](/Users/daydaylw3/Pictures/typora/image-20220511151353984.png)

因为一个槽占用2 字节，各个槽之间是挨着的，而且官们代表的记录的主键值都是从小到大排序的，所以可以使用二分法快速查找. 5 个槽的编号分别是0 、1 、2 、3 、4. 所以初始情况下最低的槽就是low=0，最高的槽就是high=4

找主键值为6 的记录

1. 计算中间稽的位置。(0+4)/2=2. 查看槽2 对应记录的主键值为8 ，又因为8> 6. 所以设置high=2. low 保持不变.
2. 重新计算中间槽的位置， (0+2)/2= 1. 查看槽l 对应记录的主键值为4. 又因为4 < 6.所以设置low= 1 . hi gh 保持不变.
3. 因为high 一l ow 的值为1. 所以确定主键值为6 的记录在稽2 对应的组中.此时需要找到槽2 所在分组中主键值最小的那条记录，然后沿着单向链表遍历槽2 中的记录。可以很轻易地找到槽 1对应的记录(主键值为4 )，这条记录的下一条记录就是槽 2 所在分组中主键值最小的记录，其主键值为5. 所以，我们可以从这条主键值为5 的记录出发，遍历槽2 中的各条记录，直到找到主键值为6 的那条记录即可
4. 由于一个组中包含的记录条数最多是 8 条，所以遍历一个组中的记录的代价是很小的.

在一个数据页中查找指定主键值的记录时，**过程**分为两步

1. 通过二分法确定该记录所在分组对应的槽，然后找到该槽所在分组中主键值最小的那
2. 通过记录的next record 属性遍历该槽所在的组中的各个记录.

## 5.5 Page Header（页面头部）

存储各种状态信息：比如数据页中已经存储了多少条记录、Free Space 在页面中的地址偏移量、页目录中存储了多少个槽等

占用固定的 56 字节

| 状态名称            | 占用空间大小（字节 | 描述                                                         |
| ------------------- | ------------------ | ------------------------------------------------------------ |
| `PAGE_N_DIR_SLOTS`  | 2                  | 在页目录中的槽数量                                           |
| `PAGE_HEAP_TOP`     | 2                  | 还未使用的空间最小地址， 也就是说从该地址之后就是Free Space  |
| `PAGE_N_HEAP`       | 2                  | 第 1 位表示本记录是否为紧凑型的记录， 剩余的15 位表示本页的堆中记录的数量〈包括lnfumnn 和Supremum 记录以及标记为"己删除"的记录) |
| `PAGE_FREE`         | 2                  | 各个己删除的记录通过next record 组成一个单向链衰，这个单向链表中的记录所占用的存储空间可以被重新利用PAGE FREE 表示该链表头节点对应记录在页面中的偏移量 |
| `PAGE_GARBAGE`      | 2                  | 己删除记录占用的字节数                                       |
| `PAGE_LAST_INSERT`  | 2                  | 最后插入记录的位置                                           |
| `PAGE_DIRECTION`    | 2                  | 记录插入的方向                                               |
| `PAGE_N_DIRECTION`  | 2                  | 一个方向连续插入的记录数量                                   |
| `PAGE_N_RECS`       | 2                  | 该页中用户记录的数量〈不包括lnfumnn 和Supremum记录以及被删除的记录) |
| `PAGE_MAX_TRX_ID`   | 8                  | 修改当前页的最大事务id. 该值仅在二级索引页面中定义           |
| `PAGE_LEVEL`        | 2                  | 当前页在B+ 树中所处的层级                                    |
| `PAGE_INDEX_ID`     | 8                  | 索引ID， 表示当前页属于哪个索引                              |
| `PAGE_BTR_SEG_LEAF` | 10                 | B+ 树叶子节点段的头部信息，仅在B+ 树的根页面中定义           |
| `PAGE_BTR_SEG_TOP`  | 10                 | B+ 树非叶子节点段的头部信息，仅在B+ 树的根页面定义           |

**PAGE_DIRECTION**：假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左边.用来表示最后一条记录插入方向的状态就是 PAGE DIRECTION.

**PAGE_N_DIRECTION**：假设连续几次插入新记录的方向都是一致的. InnoDB 会把沿着同一个方向插入记录的条数记下来，这个条数就用PAGE_N_DIRECTION 状态表示。如果最后一条记录的插入方向发生了改变，这个状态的值会被消零后重新统计.

## 5.6 File Header（文件头部）

描述了一些通用于各种页的信息：页的编号、上一个页和下一个页是谁等等

占用固定 38 字节

| 状态名称                           | 占用空间大小（字节 | 描述                                                         |
| ---------------------------------- | ------------------ | ------------------------------------------------------------ |
| `FIL_PAGE_SPACE_OR_CHKSUM`         | 4                  | 当MySQL 的版本低于4.0.14 时，该属性表示本页面所在的表空间ID: 在之后的版本中，该属性表示页的校验和（checksum) |
| `FIL_PAGE_OFFSET`                  | 4                  | 页号                                                         |
| `FIL_PAGE_PREV`                    | 4                  | 上一个页的页号                                               |
| `FIL_PAGE_NEXT`                    | 4                  | 下一个页的页号                                               |
| `FIL_PAGE_LSN`                     | 8                  | 页面被最后修改时对应的 LSN（Log Sequence Number，日志序列号）值 |
| `FIL_PAGE_TYPE`                    | 2                  | 该页的类型                                                   |
| `FIL_PAGE_FILE_FLUSH_LSN`          | 8                  | 仅在系统表空间的第一个页中定义，代表文件至少被刷新到了对应的LSN 值 |
| `FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID` | 4                  | 页属于哪个表空间                                             |

**FIL_PAGE_OFFSET**：每一个页都有一个单独的页号， InnoDB 通过页号来唯一定位一个页.

**FIL_PAGE_TYPE**：表示当前页的类型

| 类型名称                  | 十六进制 | 描述                            |
| ------------------------- | -------- | ------------------------------- |
| `FIL_PAGE_TYPE_ALLOCATED` | 0x0000   | 最新分配， 还未使用             |
| `FIL_PAGE_UNDO_LOG`       | 0x0002   | undo 日志页                     |
| `FIL_PAGE_INODE`          | 0x0003   | 存储段的信息                    |
| `FIL_PAGE_IBUF_FREE_LIST` | 0x0004   | Cbange Buπer 空闲列表           |
| `FIL_PAGE_IBUF_BITMAP`    | 0x0005   | Change BuJfer 的一些属性        |
| `FIL_PAGE_TYPE_SYS`       | 0x0006   | 存储一些系统数据                |
| `FIL_PAGE_TYPE_TRX_SYS`   | 0x0007   | 事务系统数据                    |
| `FIL_PAGE_TYPE_FSP_HDR`   | 0x0008   | 表空间头部信息                  |
| `FIL_PAGE_TYPE_XDES`      | 0x0009   | 存储区的一些属性                |
| `FIL_PAGE_TYPE_BLOB`      | 0x000A   | 溢出页                          |
| `FIL_PAGE_INDEX`          | 0x45BF   | 索引页， 也就是我们所说的数据页 |

**FIL_PAGE_PREV** 和 **FIL_PAGE_NEXT**：存储本数据页的上一个和下一个页号，建立一个双向链表把许多的页串起来；并不是所有页都有这两个属性

## 5.7 File Trailer（文件尾部）

检测一个页是否完整(也就是在刷新时有没有发生只刷新了一部分的尴尬情况)，设计InnoDB 的大叔在每个页的尾部都加了一个FileTailer 部分，这个部分由8 字节组成，可以分成2 个小部分.

+ 前4 字节代表页的校验和

  这个部分与Fi1e Header 中的校验和相对应.每当一个页面在内存中发生修改时，在刷新之前就要把页面的校验和算出来。因为File Header 在页面的前边，所以File Header 中的校验和会被首先刷新到磁盘，当完全写完后，校验和也会被写到页的尾部.如果页面刷新成功，则页首和页尾的校验和应该是一致的

+ 后4 字节代表页面被最后修改时对应的LSN 的后4 字节

  正常情况下应该与 File Header 部分的 FIL_PAGE_LSN 的后4 字节相同.这个部分也是用于校验页的完整性

## 5.8 总结

+ 页有很多类型，存放记录的页称为数据页
+ 一个数据页可以被大致划分内7 个部分
  + `File Header`
  + `Page Header`
  + `Infimum` + `Supremum`
  + `User Records`：真正存储我们插入的记录， 大小不固定.
  + `Free Space`
  + `Page Directory`
  + `File Tailer`
+ 每个记录的头信息中都有一个next record 属性，从而可以使页中的所有记录串联成一个**单向链表**
+ lnnoDB 会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽，存放在Page D i rectory 中
+ 一个页中根据主键查找记录的步骤
+ 每个数据页的File Header 部分都有上一个页和下一个页的编号，所以所有的数据页会组成一个**双向链表**
+ 在将页从内存刷新到磁盘时，为了保证页的完整性，页首和页尾都会存储页中数据的校验和，以及页面最后修改时对应的LSN 值

------

[toc]
