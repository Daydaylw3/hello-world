[toc]

## 1.6 服务器处理客户端请求

以比较复杂的查询请求为例来展示一下大致的过程

大致需要分为3 部分:

+ 连接管理
+ 解析与优化
+ 存储引擎

### 1.6.1 连接管理

> 当该客户端退出时会与服务器断开连接， 服务器并不会立即把与该客户端交互的线程销毁， 而是把它缓存起来， 在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端.这样就不用频繁地创建和销毁线程，从而节省了开销。

我们也需要限制可以同时连接到服务器的客户端数量

服务器程序会对客户端程序提供的主机信息、用户名、密码等信息进行认证

### 1.6.2 解析与优化

查询缓存、语法解析和查询优化

#### 1.6.2.1 查询缓存

> 把刚刚处理过的查询请求和结果缓存起来. 如果下一次有同样的请求过来，直接从缓存中查找结果就好了

+ 查询缓存可以在不同的客户端之间共享
+ 两个查询请求有任何字符上的不同（例如，空格、注释、大小写）都会导致缓存不会命中
+ 如果查询请求中包含某些系统函数、用户自定义变量和函数、系统表，如 `mysql 、information_schema、performance_schema` 数据库中的表，则这个请求就不会被缓存
+ MySQL 的缓存系统会监测涉及的每张表，只要该表的结构或者数据被修改，则与该表有关的所有查询缓存都将变为无效并从查询缓存中删除！

> 从MySQL 5.7.20 开始，不推荐使用查询缓存， 在MySQL8.0 中直接将其删除

#### 1.6.2.2 语法解析

> 判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到MySQL 服务器内部使用的一些数据结构上

+ 算是一个编译过程
+ 词法解析
+ 语法分析
+ 语义分析

服务器程序获得到了需要的信息，比如要查询的表和列是哪些、搜索条件是什么等

#### 1.6.2.3 查询优化

> MySQL 的优化程序会对我们的语句做一些优化以提高执行效率

优化的结果就是生成一个执行计划，表明了应该使用哪些索引执行查询，以及表之间的连接顺序是啥样，等等

使用 `explain` 语句查看执行计划

### 1.6.3 存储引擎

> MySQL 服务器把数据的存储和提取操作都封装到了一个名为存储引擎的模块中。
>
> 在物理上如何表示记录，怎么从表中读取数据，以及怎么把数据写入具体的物理存储器上，都是存储引擎负责的事情。

存储引擎以前的叫法是 `表处理器`，它的功能就是接收上层传下来的指今，然后对表中的数据进行读取或写入操作。

+ 为了方便管理，人们把处理请求的过程简单地划分为 `server` 层和存储引擎层
+ `server` 层：并不涉及真实数据存取
+ 存储引擎层：存取真实数据
+ 各种不同的存储引擎为 `server` 层提供统一的调用接口

**重要**

+ `server` 层和存储引擎层交互时，一般是以记录为单位的
    1. `server` 层根据执行计划先向存储引擎层取一条记录
    2. 判断是否符合 `WHERE` 条件
    3. 符合， 就发送给客户端
    4. 否则跳过该记录，然后继续向存储引擎索要下一条记录
    5. 以此类推

> `server` 层在判断某条记录符合要求之后，其实是先将其发送到一个缓冲区，待到该缓冲区满了，才向客户端发送真正的记录.该缓冲区大小由系统变量 `net_buffer_length` 控制

## 1.7 常用存储引擎

最常用的就是 `InnoDB` 和 `MyISAM`. 偶尔还会提一下 `MEMORY`

> `lnnoDB` 从 `MySQL5.5.5` 版本开始作为 MySQL 的默认存储引擎，之前版本的默认存储引擎为 `MyISAM`

## 1.8 关于存储引擎的一些操作

### 1.8.1 查看当前服务器程序支持的存储引擎

```mysql
mysql> show engines;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
9 rows in set (0.17 sec)
```

+ `Support` 列表示该存储引擎是否可用
  + `DEFAULT` 值代表当前服务器程序的默认存储引擎
+ `Comment` 列是对存储引擎的一个描述
+ `Transactions` 列代表该存储引擎是否支持事务处理 
+ `XA` 列代表该存储引擎是否支持分布式事务
+ `Savepoints` 列代表该存储引擎是否支持事务的部分回滚

### 1.8.2 设置表的存储引擎

> 为**不同的表**设置不同的存储引擎.也就是说， 不同的表可以有不同的物理存储结构、不同的读取和写入方式

#### 1.8.2.1 创建表时指定存储引擎

> 没有指定就使用默认

```mysql
CREATE TABLE 表名 {
	建表语句;
} ENGINE = 存储引擎名称，
```

#### 1.8.2.2 修改表的存储引擎

```mysql
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```

## 1.9 总结

------



[toc]

