[toc]

----

第 1 章曾经讲过， MySQL Sever 有一个称为优化器的模块. MySQL Server 在对一条查询语句进行语法解析之后，就会将其交给优化器来优化，优化的结果就是生成一个所谓的**执行计划**。

这个执行计划表明了应该使用哪些索引进行查询、表之间的连接顺序是啥样的；等等。

MySQL 怎么执行单表查询的

```mysql
CREATE TABLE single_table (
	id INT NOT NULL AUTO_INCREMENT,
	key1 VARCHAR(100),
	key2 INT,
	key3 VARCHAR(100),
	key_part1 VARCHAR(100),
	key_part2 VARCHAR(100),
	key_part3 VARCHAR(100),
	common_field VARCHAR(100),
	PRIMARY KEY (id),
	KEY idx_key1 (key1),
	UNIQUE KEY uk_key2 (key2),
	KEY idx_key3 (key3),
	KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```

## 10.1 访问方法的概念

MySQL 执行查询语句的方式称为访问方法（access method）或者访问类型。

同一个查询语句可以使用不同的访问方法来执行，是不同的访问方法花费的时间成本可能差距甚大

## 10.2 const

可以通过主键列来定位一条记录，MySQL 会直接利用主键值在聚簇索引中定位对应的用户记录

```mysql
select * from single_table where id = 1438;
```

根据唯一二级索引列来定位一条记录的速度也是贼快的

```mysql
select * from single_table where key2 = 3841;
```

>  MySQL 的认为，通过主键或者唯一二级索引列与常数的等值比较来定位一条记录是像坐火箭一样快的，所以他们把这种通过主键或者唯一二级索号列来定位一条记录的访问方法定义为 const（意思是常数级别的， 代价是可以忽略不计的）。

不过这种 const 访问方法只能在主键列或者唯一二级索引列与一个常数进行等值比较时才有效.

如果主键或者唯一二级索引的索引列由多个列构成，则只有在索引列中的每一个列都与常数进行等值比较时，这个const 访问方法才有效（这是因为只有在该索引的每一个列都采用等值比较时，才可以保证最多只有一条记录符合搜索条件）

对于唯一二级索引列来说， 在查询列为NULL 值时，情况比较特殊。因为唯一二级索引列并不限制NULL 值的数量， 所以可能访问到多条记录。也就是说不可以使用const 访问方法来执行

## 10.3 ref

有时，我们需要将某个普通的二级索引列与常数进行等值比较

```mysql
select * from single_talbe where key1 = 'abc';
```

对于这个查询，当然可以选择全表扫描的方式来执行. 不过也可以使用idx_keyl 来执行，此时对应的扫描区间就是[ 'abc', 'abc'] ， 这也是一个单点扫描区间。可以定位到keyl ='abc' 条件的第一条记录， 然后沿辑记录所在的单向链表向后扫描，直到某条记录不符合key l ='abc' 条件为止。由于查询列表是 `*` 因此针对获取到的每一条二级索引记录，都需要根据该记录的id 值执行回表操作。到聚簇索引中获取到完整的用户记录后再发送给客户端

由于普通二级索引并不限制制列值的唯一性，所以位于扫描区间 [ 'abc', 'abc'] 中的二级索引记录可能有多条，此时使用二级索引执行查询的代价就取决于该扫描区间中的记录条数

MySQL 把这种 “搜索条件为二级索引列与常数进行等值比较，形成的扫描区间为单点扫描区间，采用二级索引来执行查询” 的访问方法称为 ref

> 采用二级索引来执行查询时， 其实每获取到一条二级索引记录， 就会立刻对其执行回表操作，而不是将所有二级牵引记录的主键值都收集起来后再统一执行回表操作

对于普通的二级索引来说，通过索引列进行等值比较后可能会匹配到多条连续的二级索引记录，而不是像主键或者唯一二级索引那样最多只能匹配一条记录。所以这种 ref 访问方法比 const 差了那么一点

+ 在二级索引列允许存储NULL 值时，无论是普通的二级索引，还是唯一二级索引，它们的索引列并不限制NUtL 值的数量，所以在执行包含"key IS NULL" 形式的搜索条件的查询时，最多只能使用ref 访问方法， 而不能使用const 访问方法.
+ 对于索引列中包含多个列的二级索引来说，只要最左边连续的列是与常数进行等值比较，就可以采用ref访问方法

## 10.4 ref_or_null

有时， 我们不仅想找出某个二级索引列的值等于某个常数的记录，而且还想把该列中值为NULL 的记录也找出来.

```mysql
select * from single_table where key1 = 'abc' or key1 is null;
```

当使用二级索号|而不是全表扫描的方式执行该查询时，对应的扫描区间就是 [NULL， NULL] 和 ['abc', 'abc']，，此时执行这种类型的查询所使用的访问方法就称为 ref_or_null

<img src="/Users/daydaylw3/Pictures/typora/image-20220516144712252.png" alt="image-20220516144712252" style="zoom:80%;" />

> 值为NULL 的记录会被放在索引的最左边

## 10.5 range

有时我们面对的搜索条件很复杂

```mysql
select * from single_table where key2 in (1438, 6328) or (key2 >= 38 and key2 <= 79);
```

如果使用 idx_key2 执行该查询， 那么对应的扫描区间就是 [1438， 1438] 、[6328 ， 6328] 以及[38 ， 79]。MySQL 把 “使用索引执行查询时， 对应的扫描区间为若干个单点扫锚区间或者范围扫描区间” 的访问方法称为range（仅包含一个单点扫描区间的访问方法不能称为range 访问方法，扫描区间为(-∞，+∞)的访问方法也不能称为range 访问方法）

## 10.6 index

```mysql
select key_part1, key_part2, key_part3 from single_table where key_part2 = 'abc';
```

由于 key_part2 并不是联合索引idx_key yart 的索引列中最左边的列， 所以无法形成合适的范围区间来减少需要扫描的记录数量，从而无法使用时或者range 访问方法来执行这个语句.但是这个查询符合下面这两个条件:

+ 它的查询列表只有 key_part 1, key_part2 和key_part3 这3 个列， 而索引 idx_key_part 又恰好包含这 3 个列
+ 搜索条件中只有key_part2 列， 这个列也包含在索引idx_ key_part 中

也就是说，我们可以直接遍历idx_key_part 索引的所有二级索引记录， 针对获取到的每一条二级索引记录，都判断 key_part2 = 'abc' 条件是否成立.如果成立，就从中读取出 key_part 1, key_part2 和key_part3 这3 个列的值并将它们发送给客户端。在这种使用 idx_key_part 索引执行上述查询的情况下，对应的扫锚区间就是(-∞ ， +∞ ) 

由于二级索寻|记录比聚簇索记录小得多，而且这个过程也不用执行回表操作， 所以直接扫描全部的二级索引记录比直接扫描全部的聚簇索引记录的成本要小很多。MySQL 把这种扫描全部二级索引记录的访问方法称为index 访问方法

另外，当通过全表扫描对使用lnnoDB 存储引擎的表执行查询时， 如果添加了 “ORDER BY 主键” 的语句，那么该语句在执行时也会被人为地认定为使用的是index 访问方法

```mysql
select * from single_table order by id;
```

## 10.7 all

最直接的查询执行方式就是全表扫描，对于InnoDB 表来说也就是直接扫描全部的聚簇索引记录

MySQL 把这种使用全表扫描执行查询的访问方法称为all 访问方法

## 10.8 注意事项

### 10.8.1 重温二级索引 + 回表

在使用索引来减少需要扫描的记录数量时， 一熊情况下只会为单个索引生成扫描区间

```mysql
select * from single_table where key1 = 'abc' and key2 > 1000;
```

查询优化器会识别到查询中两个搜索条件

+ key1 = 'abc'，如果使用 idx_key1 执行查询，对应的扫描区间就是['abc'， 'abc'] ;
+ key2 > 1000，如果使用 uk_key2 执行查询， 对应的扫描区间就是( 100， +∞).

优化器会通过访问表中的少量数据或者直接根据事先生成的统计数据， 来计算['abc' ，'abc'] 扫描区间包含多少条记录，再计算( 100，+∞)扫描区间包含多少条记录， 之后再通过一定算法来计算使用这两个扫描区间执行查询时的成本分别是多少， 最后选择成本更小的那个扫描区间对应的索引执行查询

> 每次从二级索引中读取到一条记录后，就会根据该记录的主键位执行回农操作.而在某个扫描区间中的二级索引记录的主键值是无序的，也就是说这些二级索引记录对应的聚簇索引记录所在的页面的页号是无序的.每次执行回农操作时都相当于要随机读取一个聚簇索引页面，而这些随机 `I/O` 带来的性能开销比较大. 于是 MySQL 提出了一个名为 Disk-Sweep Multi-Range Read（MRR，多范围读取）的优化措施，先读取一部分二级索引记录，将它们的主键值排好序之后再统一执行回表操作。相对于每读取一条二级索引记录就立即执行回农操作，这样会节省一些 `I/O` 开销.当然使用这个 MRR 优化措施的条件比较苛刻

### 10.8.2 索引合并

在特殊情况下，MySQL 也可能为多个索引生成扫描区间。MySQL 把这种使用多个索引来完成一次查询的执行方法称为 index merge (索引合并〉

#### 1. Intersection 索引合并

```mysql
select * from single_table where key1 = 'a' and key3 = 'b';
```

可以使用下面两种方案执行该查询

+ 使用 idx_key1 索引执行该查询，此时对应的扫描区间就是['a', 'a']。对于获取到的每条二级索引记录，根据它的 id 值执行回表操作后获取到完整的用户记录，再判断 key3 = 'b' 条件是否成立。
+ 使用 idx_key3 索引执行该查询，此时对应的扫描区间就是['a', 'a']。对于获取到的每条二级索引记录，根据它的 id 值执行回表操作后获取到完整的用户记录，再判断 key1 = 'a' 条件是否成立。

注意到上述两种方案的扫描区间都是单点扫描区间，意味着这些二级索引记录其实是**按照主链值迸行排序**的

还有一种方案

+ 方案 1 和方案 2 的获得的二级索引记录，从两个方案的操作结果中找到 id 列值相同的记录（找到共有的 id 值）。然后再进行回表，这样可能省下了很多回表操作带来的开销

这里的方案3 就是所谓的 Intersection 索引合并。Intersection 索引合并指的就是对从不同索引中扫描到的记录的id 值取交集，只为这些id 值执行回表操作。

如果使用 Intersection 索引合并的方式执行查询，并且每个使用到的索引都是二级索引的话，则要求**从每个索引中获取到的二级索引记录都是按照主键值排序的**

+ 从两个有序集合中取交集比从两个无序集合中取交集要容易得多:
+ 如果获取到的id 值是有序排列的，则在根据这些id 值执行回表操作时就不再是进行单纯的随机 `I/O` ( 这些id 值是有序的) ，从而会提高效率

聚簇索引是比较特殊的存在，因为聚簇索引记录本身就是按照主键值进行排序的

#### 2. Union 索引合并

```mysql
select * from single_table where key1 = 'a' or key3 = 'b';
```

我们可以同时使用 idx_key l 和idx_key3 来执行查询。也就是在idx_key l 中扫描keyl 值位于 ['a', 'a'] 区间中的二级索引记录， 同时在idx_key3 中扫描key3 值位于 ['b', 'b'] 区间中的二级索引记录，然后根据二级索引记录的id 值在两者的结果中进行去重，再根据去重后的id 值执行回表操作，这样重复的id 值只需回表一次

这种方案就是所谓的 union 索引合并

如果使用Union 索引合并的方式执行查询，并且每个使用到的索引都是二级索引的话，则要求从每个索引中获取到的二级索引记录都是按照主键值排序的

+ 从两个有序集合执行去重操作比从两个无序集合中执行去重操作容易一些
+ 如果获取到的id 值是有序排列的，则在根据这些id 值执行回表操作时就不再是进行单纯的随机 `I/O` ( 这些id 值是有序的) ，从而会提高效率

聚簇索引是比较特殊的存在，因为聚簇索引记录本身就是按照主键值进行排序的

#### 3. Sort-Union 索引合并

```mysql
select * from single_table where key1 < 'a' or key3 > 'z';
```

这个查询无法使用Union 索引合并

+ 先根据key1 <'a' 条件从idx_keyl 二级索引中获取二级索引记录，并将获取到的二级索引记录的主键值进行排序
+ 再根据key3 > 'z' 条件从idx_key3 二级索引中获取二级索引记录，并将获取到的二级索号|记录的主键值进行排序
+ 因为上述两个二级索让键值都是排好序的， 所以剩下的操作就与Union 索引合并方式一样了

我们把上面这种"先将从各个索引中扫描到的记录的主键值进行排序，再按照执行Union 索引合并的方式执行查询" 的方式称为Sort-Union 索引合并。

## 10.9 总结

----

[toc]