[toc]

------

> 关系型数据库一个至关重要的概念就是Join (连接)

## 11.1 连接简介

### 11.1.1 连接的本质

```mysql
mysql> create table t1 (m1 int, n1 char(1));
Query OK, 0 rows affected (0.01 sec)

mysql> create table t2 (m2 int, n2 char(1));
Query OK, 0 rows affected (0.01 sec)

mysql> insert into t1 values (1, 'a'), (2, 'b'), (3, 'c');
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> insert into t2 values (2, 'b'), (3, 'c'), (4, 'd');
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0
```

我们成功建立了 tl 、 t2 两个表.这两个表都有两个列：一个是 INT类型的，另外一个是CHAR(1) 类型的。

从本质上来说，连接就是把各个表中的记录都取出来进行依次匹配，并把匹配后的组合发送给客户端

![image-20220516163053691](/Users/daydaylw3/Pictures/typora/image-20220516163053691.png)

这个过程看起来就是把t1 表中的记录和应表中的记录连起来组成-个新的更大的记录，所以这个查询过程称为连接查询

如果连接查询的结果集中包含-个表中的每-条记录与另一个表中的每-条记录相互匹配的组合，那么这样的结果集就可以称为笛卡儿积

```mysql
mysql> select * from t1, t2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    1 | a    |    2 | b    |
|    2 | b    |    2 | b    |
|    3 | c    |    2 | b    |
|    1 | a    |    3 | c    |
|    2 | b    |    3 | c    |
|    3 | c    |    3 | c    |
|    1 | a    |    4 | d    |
|    2 | b    |    4 | d    |
|    3 | c    |    4 | d    |
+------+------+------+------+
9 rows in set (0.00 sec)
```

### 11.1.2 连接过程简介

我们可以连接任意数量的表.但是如果不附加任何限制条件，这些表连续起来产生的笛卡儿积可能是非常巨大的。所以在连接时过滤掉特定的记录组合是有必要的.

+ 涉及单表的条件：
+ 涉及两表的条件：

携带过滤条件的连接查询的大致执行过程

```mysql
select * from t1, t2 where t1.m1 > 1 and t1.m1 = t2.m2 and t2.n2 < 'd';
```

+ 首先确定第一个需要查询的表， 这个表称为驱动表

  这里假设使用t1 作为驱动衰，那么就需要到 tl 表中查找满足t1.m1> 1 的记录

  ![image-20220516163803192](/Users/daydaylw3/Pictures/typora/image-20220516163803192.png)

+ 步骤1 中从驱动表每获取到一条记录，都需要到 t2 表中查找匹配的记录。

  所谓匹配的记录，指的是符合过滤条件的记录。

  因为是根据 t1 表中的记录去找 t2 表中的记录，所以 t2 表也可以称为被驱动表

  此时涉及两个表的列的过滤条件 t1.m1 = t2.m2

  + 对于从t1 表中查询得到的第一条记录，也就是当 t1.m1=2 时，到 t2 表中做单表查询

  + 对于从t1 表中查询得到的第二条记录，也就是当 t1.m1=3 时，到 t2 表中做单表查询

这个两表连接查询共需要查询 1 次 t1 表、2 次 t2 表。

> 在两表的连接查询中，驱动表只需访问一次，被驱动表可能要访问多次

> 每获得一条驱动表记录，就立即到被驱动表中寻找匹配的记录

### 11.1.3 内连接和外连接

```mysql
mysql> create table student (
    -> number int not null auto_increment comment '学号',
    -> name varchar(5) comment '姓名',
    -> major varchar(30) comment '专业',
    -> primary key (number)
    -> ) engine=InnoDB charset=utf8 comment '学生信息表';
Query OK, 0 rows affected, 1 warning (0.01 sec)

mysql>  create table score (
    -> number int comment '学号',
    -> subject varchar(30) comment '科目',
    -> score tinyint comment '成绩',
    -> primary key (number, subject)
    -> )engine = InnoDB charset=utf8 comment '学生成绩表';
Query OK, 0 rows affected, 1 warning (0.01 sec)
```

```mysql
mysql> select * from student;
+----------+--------+--------------------------+
| number   | name   | major                    |
+----------+--------+--------------------------+
| 20220101 | 张三   | 软件学院                 |
| 20220102 | 李四   | 计算机科学与工程         |
| 20220103 | 王五   | 计算机科学与工程         |
+----------+--------+--------------------------+
3 rows in set (0.00 sec)

mysql> select * from score;
+----------+-------------------------+-------+
| number   | subject                 | score |
+----------+-------------------------+-------+
| 20220101 | MySQL是怎样运行的       |    78 |
| 20220101 | 深入浅出MySQL           |    88 |
| 20220102 | MySQL是怎样运行的       |   100 |
| 20220102 | 深入浅出MySQL           |    98 |
+----------+-------------------------+-------+
4 rows in set (0.00 sec)
```

把各位学生的考试成绩都查询出来

```mysql
mysql> select s1.number, s1.name, s2.subject, s2.score from student as s1, score as s2 where s1.number=s2.number;
+----------+--------+-------------------------+-------+
| number   | name   | subject                 | score |
+----------+--------+-------------------------+-------+
| 20220101 | 张三   | MySQL是怎样运行的       |    78 |
| 20220101 | 张三   | 深入浅出MySQL           |    88 |
| 20220102 | 李四   | MySQL是怎样运行的       |   100 |
| 20220102 | 李四   | 深入浅出MySQL           |    98 |
+----------+--------+-------------------------+-------+
4 rows in set (0.00 sec)
```

可是有个问题：王五同学因为某些原因没有参加考试，所以在 score 表中没有对应的成绩记录。如果老师想查看所有学生的考试成绩，即使是缺考的学生， 他们的成绩也应该展示出来

针对驱动表中的某条记录，即使在被驱动表中没有找到与之匹配的记录，也仍然需要把该驱动表记录加入到结果集

为了解决这个问题，就有了内连接和外连接的概念

+ 对于内连接的两个表，若驱动表中的记录在被驱动表中找不到匹配的记录，则该记录不会加入到最后的结果集。前面提到的连接都是内连接
+ 对于外连接的两个表，时驱动表中的记录在被驱动表中没有匹配的记录，也仍然需要加入到结果集

MySQL 中，根据选取的驱动表的不同，外连接可以细分为2 种

+ 左外连接. 选取左侧的表为驱动表.
+ 右外连接·选取右侧的表为驱动表.

即使对域外连接来说， 有时候我们也不想把驱动表的全部记录都加入到最后的结果集。于是把过滤条件分为两种，过滤条件在不同的地方是有不同的语义的

+ WHERE 子句中的过滤条件：就是平时的那种。不论是内连接还是外连接， 凡是不符合WHERE 子句中过滤条件的记录都不会被加入到最后的结果集.
+ ON 子句中的过滤条件：对于外连接的驱动表中的记录来说，如果无法在被驱动表中找到匹配ON 子句中过滤条件的记录， 那么该驱动表记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用 NULL 值填充

> 左外连接和右外连接纠别简称为左连接和右连接

#### 1. 左（外）连接的语法

```mysql
select * from t1 left [outer] join t2 on 连接条件 [where 普通过滤条件];
```

放在左边的表称为外表或者驱动表

放在右边的表称为内表或者被驱动表

> 对于左（外）连接和右（外）连接来说，必须使用 ON 子句来指出连接条件（内连接不必）

```mysql
mysql> select s1.number, s1.name, s2.subject, s2.score from student as s1 left join score as s2 on s1.number = s2.number;
+----------+--------+-------------------------+-------+
| number   | name   | subject                 | score |
+----------+--------+-------------------------+-------+
| 20220101 | 张三   | MySQL是怎样运行的       |    78 |
| 20220101 | 张三   | 深入浅出MySQL           |    88 |
| 20220102 | 李四   | MySQL是怎样运行的       |   100 |
| 20220102 | 李四   | 深入浅出MySQL           |    98 |
| 20220103 | 王五   | NULL                    |  NULL |
+----------+--------+-------------------------+-------+
5 rows in set (0.00 sec)
```

#### 2. 右（外）连接的语法

右（外）连接的原理和左（外）连接的原理是一样的

```mysql
select * from t1 right [outer] join t2 on 连接条件 [where 普通过滤条件];
```

在右(外〉连接中，只不过驱动表是右边的表，被驱动表是左边的表

#### 3. 内连接的语法

内连接和外连接的根本区别就是：在驱动表中的记录不符合ON 子句中的连接条件时，内连接不会把该记录加入到最后的结果集中

MySQL 针对内连接提供了好多不同的语法

```mysql
select * from t1 [inner | cross] join t2 [on 连接条件] [where 普通过滤条件];
```

> 在内连接中，on 子句和 where 子句是等价的

无论哪个表作为驱动表， 两表连接产生的笛卡儿积肯定是一样的

对于内连接来说，驱动表和被驱动表是可以互换的，并不会影响最后的查询结果

#### 4. 总结

```mysql
mysql> select * from t1 inner join t2 on t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
2 rows in set (0.00 sec)

mysql> select * from t1 left join t2 on t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    1 | a    | NULL | NULL |
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
3 rows in set (0.00 sec)

mysql> select * from t1 right join t2 on t1.m1 = t2.m2;
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
| NULL | NULL |    4 | d    |
+------+------+------+------+
3 rows in set (0.00 sec)
```

## 11.2 连接的原理

### 11.2.1 嵌套循环连接

> 对于两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问好多遍；具体访问几遍取决于对驱动表执行单表查询后的结果集中有多少条记录

“驱动表只访问一次，但被驱动表却可能访问多次，且访问次数取决于对驱动表执行单表查询后的结果集中有多少条记录” 的连接执行方式称为嵌套循环连接（Nested-Loop Join），这是最简单也是最笨拙的一种连接查询算法

> 对于获套循环连接算法来说，每当我们从驱动表中得到了一条记录，就根据这条记录立时到被驱动表中查询一次。如呆得到了匹配的记录，就把组合后的记录发送给客户端， 然后再到驱动表中获取下一条记录；这个过程将重复进行

### 11.2.2 使用索引加快连接速度

在嵌套循环连接中可能需要访问多次被驱动表. 如果访问被**驱动表**的方式都是全表扫描， 那得要扫描好多次

查询 t2 表其实就相当于一次单表查询，我们可以利用索引来加快查询速度

```mysql
select * from t1, t2 where t1.m1 > 1 and t1.m1 = t2.m2 and t2.n2 < 'd';
```

![image-20220516185521617](/Users/daydaylw3/Pictures/typora/image-20220516185521617.png)

查询驱动表t1 后的结果集中有2 条记录， 嵌套循环连接算法需要查询被驱动表2 次

+ 当t l. ml =2 时， 查询一遍t2 衰， 对t2 表的查询语句相当于

  ```mysql
  select * from t2 where t2.m2 = 2 and t2.n2 < 'd';
  ```

+ t l. ml =3 时， 查询一遍t2 衰， 对t2 表的查询语句相当于

  ```mysql
  select * from t2 where t2.m2 = 3 and t2.n2 < 'd';
  ```

原来的t 1. ml =t2.m2 这个涉及两个袤的过滤条件在针对t2 表进行查询时，关于t1 表的条件就己经确定了，所以我们只需要单单优化针对t2 表的查询即可

+ 在m2列上建立索引。因为针对d 列的条件是等值查找，所以可能使用到ref 访问方法。
  + 这里有一个比较特殊的情况，即假设m2列是t2 表的主键，或者是不允许存储NULL 值的唯一二级索引列，那么使用"t2.m2 =常数值"这样的条件从t2 表中查找记录时，代价就是常数级别的
  + 在连接查询中对被驱动袤的主键或者不允许存储NULL 值的唯一二级索引进行等值查找使用的访问方法就称为 **eq_ref**
+ 在 n2 列上建立索引。涉及的条件是t2.n2 < 'd'， 可能用到 range 访问方法。

假设m2和n2 列上都存在索引，那么就需要从这两个里面挑一个代价更低的索引来查询 t2 表

连接查询的查询列表和过滤条件中有时可能只涉及被驱动表的部分列，而这些列都是某个二级索引的一部分，在这种情况下即使不能使用eq_ref、ref、ref_or_null 或者 range 等访问方法来查询被驱动表，也可以通过扫描全部二级索引记录（index）来查询被驱动表

### 11.2.3 基于块的嵌套循环连续

驱动表结果集中有多少条记录，就可能把被驱动表从磁盘加载到内存中多少次。

是否可以在把被驱动表中的记录加载到内存时，一次性地与驱动表中的多条记录进行匹配呢？这样就可以大大减少重复从磁盘上加载被驱动表的代价了。

MySQL 提出了名为 Join Buffer（连接缓冲区）的概念。

Join Buffer 就是在执行连接查询前申请的一块固定大小的内存。先把若干条<u>驱动表</u>结果集中的记录装在这个 Join Buffer 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性地与 Join Buffer 中的多条驱动表记录进行匹配。

由于匹配的过程都是在内存中完成的，所以这样可以显著减少被**驱动表**的 `I/O` 代价。

<img src="/Users/daydaylw3/Pictures/typora/image-20220517004210228.png" alt="image-20220517004210228" style="zoom:67%;" />

最好的情况是 Join Buffer 足够大， 能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完成连接操作了

MySQL 把这种加入了 Join Buffer 的嵌套循环连接算法称为**基于块的嵌套循环连接（Block Nested-Loop Join）算法**。

Join Buffer 大小可以通过启动选项或者系统变量 join_buffer_size 进行配置，默认大小为 262144 字节（256KB），最小可以设置为 128 字节

> Join Buffer 中并不会存放驱动表记录的所有列，只有查询列表中的列和过滤条件中的列才会被放到 Join Buffer 中

## 11.3 总结

从本质上来说，连接就是把各个表中的记录都取出来依次进行匹配，并把匹配后的组合发送给客户端。如果不加任何过滤条件，产生的结果集就是笛卡儿积

连接分为内连接和外连接，其中外连接又可以被细分为左（外）连接和右（外）连接。

内连接和外连接的根本区别就是，在驱动表中的记录不符合ON 子句中的连接条件时，内连接不会把该记录加入到最后的结果集中，而外连接会

嵌套循环连接算法是指驱动表只访问一次， 但被驱动表却可能会访问多次，访问次数取决于对驱动表执行单表查询后的结果集中有多少条记录

由于被驱动表可能会访问多次，因此可以为被驱动表建立合适的索引以加快查询速度

如果被驱动表非常大，多次访问被驱动表可能导致很多次的磁盘 `I/O`， 此时可以使用基于块的嵌套循环连接算法来缓解由此造成的性能损耗

------

[toc]