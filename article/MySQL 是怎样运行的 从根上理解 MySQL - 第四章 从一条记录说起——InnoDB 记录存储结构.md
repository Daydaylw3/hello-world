[toc]

------

## 4.1 准备工作

表中的数据到底存到了哪里？

以什么格式存放的？

MySQL 以什么方式来访问这些数据？

不同类型的存储引擎

## 4.2 InnoDB 页简介

当我们想从表中获取某些记录时，`InnoDB` 存储引擎采取的方式是将数据划分为若干个**页**，以**页**作为磁盘和内存之间交互的基本单位

一页的大小一般为 `16KB`，是在一般情况下，一次最少从磁盘中读取 `16KB` 的内容到内存中，一次最少把内存中的 `16KB` 内容刷新到磁盘中

系统变量 `innodb_page_size` 表明了 InnoDB 存储引擎中的页大小，默认值为 `16384`（字节），也就是 `16KB`。

该变量只能在第一次初始化 MySQL 数据目录时指定，之后就再也不能更改了

```shell
mysqld --initialize
```

## 4.3 InnoDB 行格式

平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存放形式也被称为**行格式**或者**记录格式**

4 种不同类型的行格式

+ COMPACT
+ REDUNDANT
+ DYNAMIC
+ COMPRESSED

### 4.3.1 指定行格式的语法

在创建或修改表的语句中指定记录所使用的行格式

```mysql
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称;

ALTER TABLE 表名 ROW_FORMAT=行格式名称;
```

**demo**

```mysql
mysql> CREATE TABLE record_format_demo (
    -> c1 VARCHAR(10),
    -> c2 VARCHAR(10) NOT NULL,
    -> c3 CHAR(10),
    -> c4 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
Query OK, 0 rows affected (0.19 sec)

mysql> INSERT INTO record_format_demo (c1, c2, c3, c4) VALUES ('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);
Query OK, 2 rows affected (0.07 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.03 sec)
```

### 4.3.2 COMPACT 行格式

![image-20220510165004155](/Users/daydaylw3/Pictures/typora/image-20220510165004155.png)

一条完整的记录其实可以被分为记录的**额外信息**和记录的**真实数据**两大部分

#### 1. 记录的额外信息

为了更好地管理记录而不得不额外添加的一些信息

分为 3 个部分

+ 变长字段长度列表
+ NULL 值列表
+ 记录头信息

##### （1）变长字段长度列表

MySQL 支持一些变长的数据类型

拥有这些数据类型的列称为变长字段

在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来

在 `COMPACT` 行格式中，所有变长字段的真实数据占用的字节数都存放在记录的开头位置，从而形成一个变长字段长度列表；

各变长字段的真实数据占用的字节数按照列的顺序**逆序存放**

拿 `record_format_demo` 表中的第一条记录举例子：`c1、c2、c4` 列都是变长数据类型，因为表中各个列使用的都是 `ascii` 字符集，每个字符只需要一个字节来编码。第一条记录各个变长字段内容的长度：

| 列名 | 存储内容 | 内容长度（十进制 | 内容长度（十六进制 |
| ---- | -------- | ---------------- | ------------------ |
| `c1` | `'aaaa'` | 4                | 0x04               |
| `c2` | `'bbb'`  | 3                | 0x03               |
| `c4` | `'d'`    | 1                | 0x01               |

> 变长字段长度列表的字节串用十六进制表示的效果就是 `01 03 04` （空格只是为了方便理解） 

![image-20220510170612226](/Users/daydaylw3/Pictures/typora/image-20220510170612226.png)

由于第一条记录中 `c1 、c2、c4` 列中的字符串都比较短，也就是说占用的字节数比较小（`c1` 列内容是 `'aaaa'`，占用 4 字节；`c2` 列内容是 `'bbb'`，占用 3 字节；`c4` 列内容是 `'d'`，占用 1 字节），每个变长字段的内容占用的字节数用 1 字节就可以表示。

如果变长字段的内容占用的字节数比较多，可能就需要用 2 字节来表示。

`InnoDB` 有一套规则来规定于用 1 字节还是 2 字节来表示变长字段的真实数据占用的字节数。

为了更好地表述清楚这个规则，引入 `W、M 、L` 这几个符号

+ 假设某个字符集中最多需要 `W` 字节来表示一个字符（`SHOW CHARSET` 结果中的 `Maxlen` 列）

+ 对于变长类型 `VARCHAR(M)` 来说，这种类型表示能存储最多 `M` 个字符（不是字节），所以这种类型能表示的字符串最多占用的字节数就是 `M × W`

+ 假设该变长字段实际存储的字符串占用的字节数是 `L`

+ 如果 `M × W ≤ 255`，那么使用 1 字节来表示真实数据占用的字节数

  > `InnoDB` 在读取记录的变长字段长反列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于 255，可以认为只使用 1 字节来表示真实数据占用的字节数

+ 如果 `M × W > 255`，则分为两种情况

  + 如果 `L ≤ 127`，则用 1 字节来表示真实数据占用的字节数
  + 如果 `L > 127`，则用 2 字节来表示真实数据占用的字节数

  > `InnoDB` 在读取记录的变长字段长反列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于 255，`InnoDB` 使用该字节的第一个二进制位作为标志：如果该字节的第一个位为 0 ，该字节就是一个单独的字段长度（表示不大于 127 的数字时，第一位都为 0）；如果该字节的第一个位为1，该字节就是半个字段长度

> 对于一条记录来说，如果某个字段占用的字节数特别多，`InnoDB` 有可能把该字段的值的一部分数据存放到所谓的**溢出页**中，那么该字段在记录的变长字段长度列表处只存储留在本页面中的长度，所以使用 2 字节就可以表示这个留在本页面中的字节长度。尽管也是使用 2 字节，但对于溢出字段来说，采用的方案并不是单纯地将首字节的第一个二进制位置为0，而是采用了一种特殊的表示方式

> 变长字段长度列表中只存储值为非 `NULL` 的列的内容长度，不存储值为 `NULL` 的列的内容长度

也就是说对于第二条记录， 因为 `c4` 列的值为 `NULL`，所以第二条记录的变长字段长度列表只需要存储 c1 和 `c2` 列的内容长度即可

![image-20220510190018335](/Users/daydaylw3/Pictures/typora/image-20220510190018335.png)

##### （2）NULL 值列表

`COMPACT` 行格式把一条记录中值为 `NULL` 的列统一管理起来，存储到 `NULL` 值列表中

处理过程

1. 统计表中允许存储 `NULL` 的列有哪些

2. 如果表中没有允许存储 `NULL` 的列，则 `NULL` 值列表也就不存在了；否则将每个允许存储 `NULL` 的列对应一个二进制位，二进制位按照列的顺序**逆序**排列，二进制位表示的意义

   + 二进制位的值为 1 时，代表该列的值为 `NULL`
   + 二迸制位的值为 0 时，代表该列的值不为 `NULL`

   > 因为表 `record_format_demo` 有 3 个值允许为 `NULL` 的列，所以这 3 个列和二迸制位的对应关系为

   ![image-20220510192005905](/Users/daydaylw3/Pictures/typora/image-20220510192005905.png)

3. MySQL 规定 `NULL` 值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补 0

   > 表 `record_format_demo` 只有 3 个值允许为 `NULL` 的列，对应 3 个二进制位，不足一个字节，所以在字节高位补 0

   ![image-20220510192142117](/Users/daydaylw3/Pictures/typora/image-20220510192142117.png)

根据规则，两条记录的 `NULL` 列如下

![image-20220510192844911](/Users/daydaylw3/Pictures/typora/image-20220510192844911.png)

这两条记录在填充了 `NULL` 值列表后的示意图

![image-20220510192937268](/Users/daydaylw3/Pictures/typora/image-20220510192937268.png)

##### （3）记录头信息

记录头信息由固定的 5 字节（40 位）组成，用于描述记录的一些属性

![image-20220510193103852](/Users/daydaylw3/Pictures/typora/image-20220510193103852.png)

| 名称           | 大小（位 | 描述                                                         |
| -------------- | -------- | ------------------------------------------------------------ |
| 预留位 1       | 1        | 没有使用                                                     |
| 预留位 2       | 1        | 没有使用                                                     |
| `deleted_flag` | 1        | 标记该记录是否被删除                                         |
| `min_rec_flag` | 1        | B+ 树的每层非叶子节点中最小的目录项记录都会添加该标记        |
| `n_owned`      | 4        | 一个页面中的记录会被分成若干个组，每个组中有一个记录是“带头大哥”，其余记录是“小弟”。“带头大哥” 记录的值代表该组中所有的记录条数，“小弟” 记录的值都为 0 |
| `heap_no`      | 13       | 表示当前记录在页面堆中的相对位置                             |
| `record_type`  | 3        | 表示当前记录的类型，0 表示普通记录，1 表示 B+ 树非叶子节点的目录项记录，2 表示 `lnfimum` 记录，3 表示`Supremum` 记录 |
| `next_record`  | 16       | 表刁之下一条记录的相对位置                                   |

> 记录头信息的前 4 个位也被称为 info_bit

![image-20220510193906294](/Users/daydaylw3/Pictures/typora/image-20220510193906294.png)

#### 2. 记录的真实数据

对于 `record_format_demo` 表来说，记录的真实数据除了 `c1、c2、c3、c4` 这几个我们自己定义的列的数据外，MySQL 会为每个记录默认地添加一些列（也称为**隐藏列**）

| 列名           | 是否必需 | 占用空间（字节 | 描述                    |
| -------------- | -------- | -------------- | ----------------------- |
| `row_id`       | 否       | 6              | 行 ID，唯一标识一条记录 |
| `trx_id`       | 是       | 6              | 事务 ID                 |
| `roll_pointer` | 是       | 7              | 回滚指针                |

**生成主键策略**

+ 优先使用用户自定义的主键作为主键
+ 如果用户没有定义主键，则选取一个不允许存储 `NULL` 值的 `UNIQUE` 键作为主键
+ 如果不允许存储 `NULL` 值的 `UNIQUE` 键也没有定义，则 `InnoDB` 会为表默认添加一个名为 `row_id` 的隐藏列作为主键

![image-20220510194525906](/Users/daydaylw3/Pictures/typora/image-20220510194525906.png)

#### 3. CHAR(M) 列的存储格式

如果 `record_format_demo` 表采用了变长编码的字符集，虽然 `c3` 列的类型是 `CHAR(10)`，但是 `COMPACT` 行格式规定，此时该列的值占用的字节数也会被存储到变长字段长度列表中

```mysql
ALTER TABLE record_format_demo MODIFY COLUMN c3 CHAR(10) CHARACTER SET utf8;
```

修改该列字符集后，记录的变长字段长度列表也发生了变化

![image-20220510195304037](/Users/daydaylw3/Pictures/typora/image-20220510195304037.png)

 `COMPACT` 行格式还规定，采用变长编码字符集的 `CHAR(M)` 类型的列要求至少占用 `M` 字节。比如对于 `utf8` 字符集，类型为 `CHAR(10)` 的列，该列存储的数据占用的字节长度的范围为 `10 ~ 30` 字节，即使存储一个空字符串也会占用 `10` 字节。

> 这主要是希望在将来更新该列时， 在新值的字节长度大于旧值的字节长度但不大于 10 个字节时，可以在该记录处直接更新而不是在存储空间中再重新分配一个新的记录空间

### 4.3.3 REDUNDANT 行格式

![image-20220510200021151](/Users/daydaylw3/Pictures/typora/image-20220510200021151.png)

对比 `COMPACT` 行格式的不同

1. 字段长度偏移列表

   + 没有 “变长”：记录中所有列长度信息都按照逆序存储到字段长度偏移列表
   + “偏移”：是采用两个相邻偏移量的差值来计算各个列值的长度

2. 记录头信息

   + 记录头信息占用 6 字节（48 位）
   + 与 `COMPACT` 行格式的记录头信息对比
     + `REDUNDANT` 行格式多了 `n_field` 和 `1byte_offs_flag` 
     + `REDUNDANT` 行格式没有 `record_type`

3. 记录头信息中的  `1byte_offs_flag` 的值是怎么选择的

   在字段长度偏移列表中，每个列对应的偏移量可以使用 1 字节或者 2 字节来存储，那到底什么时候使用 1 字节、什么时候用 2 字节呢？这是根据该条 `REDUNDANT` 行格式记录的**真实数据占用的总大小**来判断的

   + 当记录的真实数据占用的字节数不大于 127，每个列对应的偏移量占用 1 字节
   + 当记录的真实数据占用的字节数大于 127，但不大于 32767，每个列对应的偏移量占用 2 字节
   + 真实数据大于 32767，记录的一部分已经存放到溢出页

   为了在解析记录时知道每个列的偏移量是使用 1 字节还是 2 字节表示的，`REDUNDANT` 行格式在记录头信息中放置了一个称为 `1byte_offs_flag` 的属性

   	+ 当它的值为 1 时，表明使用l 字节存储偏移量
   	+ 当它的值为 0 时，表明使用 2 字节存储偏移量

4. `REDUNDANT` 行格式中 `NULL` 值的处理

    `REDUNDANT` 行格式并没有 `NULL` 值列表，所以`REDUNDANT` 行格式在字段长度偏移列表中将列对应的偏移量值的第一个比特位作为是否为 `NULL` 的依据

> 还有一点需要注意， 对于值为 `NULL` 的列来说， 该列的类型是否为变长类型决定了该列在记录的真实数据处的存储方式

+ 定长类型，占用真实数据部分，用 `0x00` 字节填充
+ 变长类型，不占用任何存储空间

5. `CHAR(M)` 列的存储格式

   不管该列使用的字符集是啥，只要使用 `CHAR(M)` 类型，该列的真实数据占用的存储空间大小就是该字符集表示一个字符最多需要的字节数和 `M` 的乘积。

### 4.3.4 溢出列

#### 4.3.4.1 溢出列

以使用 `ASCII` 字符集的 `off_page_demo` 表为🌰

```mysql
mysql> CREATE TABLE off_page_demo (
    -> c VARCHAR(65532)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
Query OK, 0 rows affected (0.28 sec)

mysql> INSERT INTO off_page_demo (c) VALUES (REPEAT('a', 65532));
Query OK, 1 row affected (0.15 sec)
```

>  该记录的字符串实际占用的字节数是 `65532`，`InnoDB` 中一页大小一般是 `16384` 字节，显然一页也存不了一条记录。

在 `COMPACT` 和 `REDUNDANT` 行格式中，对于占用存储空间非常多的列，在记录的真实数据处只会存储该列的一部分数据，而把剩余的数据分散存储在几个其他的页中，然后在记录的真实数据处用 20 字节存储指向这些页的地址（这 20 字节还包括分散在其他页面中数据所占用的字节数）

![image-20220510210913412](/Users/daydaylw3/Pictures/typora/image-20220510210913412.png)

对于 `COMPACT` 和 `REDUNDANT` 行格式来说，如果某一列中的数据非常多，则在本记录的真实数据处只会存储该列前 `768` 字节的数据以及一个指向其他页的地址，然后把剩下的数据存放到其他页中。

![image-20220511004846335](/Users/daydaylw3/Pictures/typora/image-20220511004846335.png)

**溢出页**：这些存储 768 字节之外的数据的页面

**溢出列**：需要使用溢出页来存储的列的数据的列

#### 4.3.4.2 产生溢出页的临界点

<u>MySQL 中规定一个页中至少存放两行记录</u>

+ 每页除了存放记录之外，也需要用到 132 字节的空间存储额外的信息
+ 每个记录需要额外信息是 27 字节，包括
  + 2 字节存储真实数据长度
  + 1 字节存储列是否 `NULL`
  + 5 字节头信息
  + 6 字节 `row_id`
  + 6 字节 `trx_id`
  + 7 字节 `roll_pointer`

```
132 + 2 × (27 + n) < 16384
n = 8099
```

> 如果表中有多个列，上面的不等式要改下了，不过这临界点不是重点
>
> 存放正常记录的页面和溢出页是两种不同类型的页面，对于溢出页来说，并没有规定一个页画中最少存放两条记录

### 4.3.5 DYNAMIC 行格式和 COMPRESSED 行格式

`DYNAMIC` 和 `COMPRESSED` 行格式和 `COMPACT` 很像，只不过在处理溢出列数据时有不同

+ 他们不会在记录的真实数据处存储该溢出列真实数据的前 768 字节，而是把该列所有数据都存储到溢出页，只在记录的真实数据处存储 20 字节的溢出页地址以及真实数据占用的字节数

+ `COMPRESS` 还会采用压缩算法对页面进行压缩

![image-20220511010114953](/Users/daydaylw3/Pictures/typora/image-20220511010114953.png)

## 4.4 总结

+ 页是 `InnoDB` 磁盘和内存交互的基本单位，默认大小 16KB
+ 指定和修改行格式
+ 4 种行格式

------

[toc]