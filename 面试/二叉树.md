[toc]

# 遍历

## 层序遍历

```go
func levelOrder(root *TreeNode) [][]int {
    ret := [][]int{}
    if root == nil {
        return ret
    }
    q := []*TreeNode{root}
    for i := 0; len(q) > 0; i++ {
        ret = append(ret, []int{})
        p := []*TreeNode{}
        for j := 0; j < len(q); j++ {
            node := q[j]
            ret[i] = append(ret[i], node.Val)
            if node.Left != nil {
                p = append(p, node.Left)
            }
            if node.Right != nil {
                p = append(p, node.Right)
            }
        }
        q = p
    }
    return ret
}
```

```go
func levelOrder(root *TreeNode) [][]int {
    // 队列
    var queue []*TreeNode
    if root != nil {
        queue = append(queue, root)
    }
    var res [][]int
    for len(queue) != 0 {
        size := len(queue)
        var vec []int
        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]
            vec = append(vec, node.Val)
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        res = append(res, vec)
    }
    return res
}
```

## 前序遍历

```go
func preorderTraversal(root *TreeNode) []int {
	var res []int
	if root == nil {
		return res
	}
	tree := []*TreeNode{root}
	for len(tree) != 0 {
		node := tree[len(tree)-1]
		tree = tree[:len(tree)-1]
		res = append(res, node.Val)
		if node.Right != nil {
			tree = append(tree, node.Right)
		}
    if node.Left != nil {
      tree = append(tree, node.Left)
    }
	}
	return res
}
```

> 用栈的数据结构来存储。每读到一个数据就取出来。如果该节点有右节点，就先放右节点，如果有左折点就再放左节点。以一种右左的方式来入栈

## 中序遍历

```go
func inorderTraversal(root *TreeNode) []int {
	var res []int
	if root == nil {
		return res
	}
	
	var tree []*TreeNode
	node := root
	for node != nil || len(tree) != 0 {
    for node != nil {
      tree = append(tree, node)
      node = node.Left
    }
    node = tree[len(tree)-1]
    tree = tree[:len(tree)-1]   // 出栈
    res = append(res, node.Val) // 处理
    node = node.Right           // 指向右节点
	}
	return res
}
```

## 后序遍历

```go
func postorderTraversal(root *TreeNode) (res []int) {
    stk := []*TreeNode{}
    var prev *TreeNode
    for root != nil || len(stk) > 0 {
        for root != nil {
            stk = append(stk, root)
            root = root.Left
        }
        root = stk[len(stk)-1]
        stk = stk[:len(stk)-1]
        if root.Right == nil || root.Right == prev {
            res = append(res, root.Val)
            prev = root
            root = nil
        } else {
            stk = append(stk, root)
            root = root.Right
        }
    }
    return
}
```

```go
func postorderTraversal(root *TreeNode) []int {
	var res []int
	if root == nil {
		return res
	}
	tree := []*TreeNode{root}
	for len(tree) != 0 {
		node := tree[len(tree)-1]
		tree = tree[:len(tree)-1]
		res = append(res, node.Val)
		if node.Left != nil {
			tree = append(tree, node.Left)
		}
		if node.Right != nil {
			tree = append(tree, node.Right)
		}
	}
	return reverse(res) // 调转
}
```

# 变化

## 翻转二叉树

> 使用前序遍历 或者 后续遍历都可以

### 递归法

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    root.Left, root.Right = root.Right, root.Left
    invertTree(root.Left)
    invertTree(root.Right)
    return root
}
```

### 迭代法

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return nil
    }
    tree := []*TreeNode{root}
    for len(tree) != 0 {
        node := tree[len(tree)-1]
        tree = tree[:len(tree)-1]
        node.Left, node.Right = node.Right, node.Left
        if node.Right != nil {
            tree = append(tree, node.Right)
        }
        if node.Left != nil {
            tree = append(tree, node.Left)
        }
    }
    return root
}
```

